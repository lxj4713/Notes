{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 此为个人在工作和学习中收集并整理的笔记 var className='atoc';"},"Linux/Basics/DHCP.html":{"url":"Linux/Basics/DHCP.html","title":"DHCP","keywords":"","body":" DHCP 1.DHCP简介 2.DHCP工作原理 DHCP [ ] TODO 1.DHCP简介 DHCP(Dynamic Host Configuration Protocol.动态主机配置协议）是一个工作在应用层的局域网网络协议，数据传输时使用UDP不可靠传输协议工作，通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配网络资源，使网络环境中的主机能动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。 (例如，新的主机，自动分配获取IP地址，然后进行其他引导步骤，比如无人值守等)（其主要用途是为局域网内部的设备或网络供应商自动分配IP地址等参数。） 2.DHCP工作原理 var className='atoc';"},"Linux/Basics/RPM工具及YUM仓库.html":{"url":"Linux/Basics/RPM工具及YUM仓库.html","title":"RPM工具及YUM仓库","keywords":"","body":" RPM Yum yum 安装软件步骤 yum 常用命令 更改yum源配置 配置yum为阿里云源 配置为本地源 源码安装 apt-get 安装 RPM RPM是世界著名的Red Hat公司推出的一种软件包安装工具，全称为Redhat Package Managerrpm命令包含了五种基本功能：安装、卸载、升级、查询和验证 rpm [参数] [软件包] 常用命令 rpm -qa # 列出所有被安装的rpm package rpm -q # 查询包是否被安装 rpm -qi # 得到被安装的包的信息 rpm -ql # 列出该包中有哪些文件 rpm -qf 文件名称 # 列出服务器上的一个文件属于哪个rpm包 示例： rpm -qa |grep rsync # 软件是否安装 rpm -ivh # 安装一个包 rpm --force -ivh #强制安装 --force # 即使覆盖属于其它包的文件也强迫安装 --nodeps # 如果该RPM包的安装依赖其它包，即使其它包没装，也强迫安装。 rpm -Uvh #升级包 rpm -e #移除包 -a 查询所有的软件包 -b或-t 设置包装套件的完成阶段，并指定套件档的文件名称； -c 只列出组态配置文件，本参数需配合”-l”参数使用 -d 只列出文本文件，本参数需配合”-l”参数使用 -e或--erase 卸载软件包 -f 查询文件或命令属于哪个软件包 -h或--hash 安装软件包时列出标记 -i 显示软件包的相关信息 --install 安装软件包 -l 显示软件包的文件列表 -p 查询指定的rpm软件包 -q 查询软件包 -R 显示软件包的依赖关系 -s 显示文件状态，本参数需配合”-l”参数使用 -U或--upgrade 升级软件包 -v 显示命令执行过程 -vv 详细显示指令执行过程 Yum yum 安装软件步骤 建立本地yum源 清除yum缓存 yum clean all 重新生成yum缓存 yum makecache all 安装软件 yum install 卸载软件 yum remove yum 常用命令 yum install package #安装rpm包 yum remove package #卸载rpm包 yum update package #跟新包 yum check-update #检查可更新包 yum list #显示包列表 yum list installed | grep openssh-server # 查看 openssh-server是否 安装 更改yum源配置 配置yum为阿里云源 cd /etc/yum.repos.d/ mv CentOS-Base.repo CentOS-Base.repo.back # 备份`CentOS-Base.repo` yum网络源的配置文件 wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache 配置为本地源 vim My-Yum.repo创建新的配置文件，后缀为.repo的文件 或者更改此文件vim /etc/yum.repos.d/CentOS-Media.repo [myyum-media] #Yum软件仓库唯一标识符，避免与其他仓库冲突。 name=my-centos-yum #Yum软件仓库的名称描述，易于识别仓库用处。 # 提供的方式包括(ftp://,http://,本地 file:/// ) baseurl=file:///media/cdrom/ #本地光盘文件，必填，可以有多个 =http://mirrors.163.com/centos/$releasever/os/$basearch/ =ftp:// enabled=1 #设置此源是否可用；1为可用，0为禁用。 gpgcheck=1 #设置此源是否校验文件；1为校验，0为不校验。 gpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release #若上面参数开启校验，那么请指定公钥文件地址。 按配置参数的路径挂载光盘,并将光盘挂在信息写到/etc/fstab文件中 [root@centos1 yum.repos.d]# vim /etc/fstab /dev/cdrom /media/cdrom iso9660 defaults 0 0 mkdir -p /media/cdrom mount /dev/cdrom /media/cdrom/ #可以先挂载系统安装盘，进行本地yum源配置 yum install httpd -y 检查Yum软件仓库是否已经可用 name=CentOS-$releasever - Media #支持变量 $releasever：代表发行版的版本，从[main]部分的distroverpkg获取，如果没有，则根据redhat-release包进行判断。 $arch：cpu体系，如i686,athlon等 $basearch：cpu的基本体系组，如i686和athlon同属i386，alpha和alphaev6同属alpha。 网易CentOS yum镜像使用帮助 http://mirrors.163.com/.help/centos.html 国内开源镜像站： - 网易：http://mirrors.163.com/ - 阿里：https://developer.aliyun.com/mirror/ - 清华大学：https://mirror.tuna.tsinghua.edu.cn/ - 浙江大学：http://mirrors.zju.edu.cn/ - 北京理工大学：http://mirror.bit.edu.cn - 搜狐：http://mirrors.sohu.com/ 源码安装 追加--prefix参数，以指定稍后源码包程序的安装路径 第1步：下载及解压源码包文件。为了方便在网络中传输，源码包文件通常会在归档后使用gzip或bzip2等格式进行压缩，因此一般会具有.tar.gz与.tar.bz2的后缀。要想使用源码包安装服务程序，必须先把里面的内容解压出来，然后再切换到源码包文件的目录中： [root@linuxprobe ~]# tar xzvf FileName.tar.gz [root@linuxprobe ~]# cd FileDirectory 第2步：编译源码包代码。在正式使用源码包安装服务程序之前，还需要使用编译脚本针对当前系统进行一系列的评估工作，包括对源码包文件、软件之间及函数库之间的依赖关系、编译器、汇编器及连接器进行检查。我们还可以根据需要来追加--prefix参数，以指定稍后源码包程序的安装路径，从而对服务程序的安装过程更加可控。当编译工作结束后，如果系统环境符合安装要求，一般会自动在当前目录下生成一个Makefile安装文件。 [root@linuxprobe ~]# ./configure --prefix=/usr/local/program 第3步：生成二进制安装程序。刚刚生成的Makefile文件中会保存有关系统环境、软件依赖关系和安装规则等内容，接下来便可以使用make命令来根据Makefile文件内容提供的合适规则编译生成出真正可供用户安装服务程序的二进制可执行文件了。 [root@linuxprobe ~]# make 第4步：运行二进制的服务程序安装包。由于不需要再检查系统环境，也不需要再编译代码，因此运行二进制的服务程序安装包应该是速度最快的步骤。如果在源码包编译阶段使用了--prefix参数，那么此时服务程序就会被安装到那个目录，如果没有自行使用参数定义目录的话，一般会被默认安装到/usr/local/bin目录中。 [root@linuxprobe ~]# make install 第5步：清理源码包临时文件。由于在安装服务程序的过程中进行了代码编译的工作，因此在安装后目录中会遗留下很多临时垃圾文件，本着尽量不要浪费磁盘存储空间的原则，可以使用make clean命令对临时文件进行彻底的清理工作。 [root@linuxprobe ~]# make clean apt-get 安装 apt-get install package # 安装软件 apt-get remove package # 删除软件 apt-get purge package # 连配置一起删除 apt-cache search nurse|less # 搜索包 var className='atoc';"},"Linux/Basics/SSH 远程服务及SCP.html":{"url":"Linux/Basics/SSH 远程服务及SCP.html","title":"SSH 远程服务及SCP","keywords":"","body":" SSH远程服务 ssh安装 ssh 远程连接 ssh配置文件 ssh-key 安全密钥 访问控制 SCP 远程传输 sftp rsync SSH远程服务 ssh 服务包括 ssh，scp，sftp，rsync。 ssh安装 yum list installed | grep openssh-server # 验证是否安装 yum install openssh-server # 安装 ps -e | grep sshd [netstat -an | grep 22] # 检查进程或端口号 systemctl enable sshd.service # sshd 服务添加至自启动列表中 systemctl list-unit-files | grep sshd #查看是否开启了sshd 服务自启动 ssh 远程连接 ssh [-p(小写)] root@192.168.137.128 #ssh远程连接 ssh root@172.25.0.11 touch/root/Desktop/file ssh 远程主机用户@远程主机ip command ##直接在远程主机运行某条命令 ssh配置文件 vim /etc/ssh/sshd_config 配置文件参数 作用 Port 22 TCP 默认端口为22，最好进行修改一个高位端口(TCP端口范围1-65535) PubkeyAuthentication yes 密钥认证登陆 ssh-key AuthorizedKeysFile .ssh/authorized_keys 默认公钥存放的位置 PasswordAuthentication no 禁止密码登陆 PermitRootLogin no 禁止root认证登录(生产环境最好禁止root和密码登陆) ListenAddress 192.168.137.130 限制ssh监听IP，有些服务器安全级别更高，不允许外网直接登陆，只有通过局域网才能登陆，可以在机房里设置一台能够被外网远程连接，其他的主机都通过这个机器进行远程连接即可 StrictModes yes 当远程用户的私钥改变时直接拒绝连接 MaxAuthTries 6 最大密码尝试次数 MaxSessions 10 最大终端数 PermitEmptyPasswords no 是否允许空密码登录(很不安全) systemctl restart sshd #配置后需重启ssh服务 ssh-key 安全密钥 [root@localhost ~]# ssh-keygen [root@localhost ~]# ssh-keygen[root@localhost ~]# ssh-keygen -t rsa -b 2048 -P '' 生成公私钥对。 -t 指定加密类型（rsa/dsa) -b 指定密钥对加密长度（最好选1024位以上，如2048） 其中-P表示密码，-P '' 就表示空密码，也可以不用-P参数，这样就要三车回车，用-P就一次回车, -t表示密钥的加密类型,可以选择的加密类型有：dsa, ecdsa, ed25519, rsa, rsa1 [root@localhost .ssh]# ls /root/.ssh id_rsa id_rsa.pub [root@localhost .ssh]# ssh-copy-id -i lxj@192.68.10.10 此条命令,上传公钥，上传到 服务器/etc/.ssh/目录下 [root@localhost .ssh]# scp /root/.ssh/id_rsa.pub root@192.168.10.10:/root/.ssh/authorized_keys 或者手动SCP拷贝到目标主机. authorized_keys的权限要是600!!! [root@localhost ~]# chmod 600 /root/.ssh/authorized_keys [root@localhost .ssh]# ssh-copy-id @192.68.10.10 [root@localhost .ssh]# vim /etc/ssh/sshd_config 设置只允许密钥验证,然后重启服务器 78 PasswordAuthentication no [root@localhost .ssh]# systemctl restart sshd id_rsa 私钥 需要保密 id_rsa.pub 公钥,上传服务器 [ ] TODO 访问控制 #控制ssh客户端访问 vim /etc/hosts.deny vim /etc/hosts.allow sshd:172.25.254.250 ##允许250主机链接sshd sshd:172.25.254.250， 172.25.254.180 ##允许250和180链接 sshd:ALL EXCEPT 172.25.254.200 ##只不允许200链接sshd #ssh登陆提示修改该 vim /etc/motd ##显示登陆后字符 密钥对验证： 连接前，将客户机client公钥放在服务器server上 连接时，client将用公钥去请求server，server会要求client接收server自己的公钥(server密钥对自动生成) 第一次连接时，server接收client发来的公钥，并验证本地存放的公钥和接收的client公钥是否一致，若不一致则直接拒接，若一致，则用client公钥加密一段信息，发给client client收到加密信息后，使用client私钥解密，并用server公钥加密信息，发给server server收到数据包后使用server私钥进行解密，若解密成功，内容和之前发送的信息一致，则建立了安全的远程连接 ~~~ centos6.x #临时关闭 iptables -F #清空防火墙规则 setenforce 0 #临时关闭SELinux ~~~ ~~~ ~~~ #永久关闭 chkconfig iptables off #设置防火墙开机不自启动 sed -i '7s/enforcing/disabled/' /etc/selinux/config #永久关闭SELinux # 需重启服务器才能生效 ~~~ SCP 远程传输 scp（secure copy）是一个基于SSH协议在网络之间进行安全传输的命令 -v 显示详细的连接进度 -P(大写) 指定远程主机的sshd端口号 -r 用于传送文件夹/目录 -6 使用IPv6协议 scp [参数] 本地文件 远程帐户@远程IP地址:远程目录 上传到远程 [root@linuxprobe ~]# scp /root/readme.txt lxj@192.168.10.20:/home scp [参数] 远程用户@远程IP地址:远程文件 本地目录 下载到本地主机 [root@linuxprobe ~]# scp root@192.168.10.20:/etc/redhat-release /root SCP 不适合用来做备份,文件权限,日期属性等都会发生改变 [ ] TODO sftp rsync var className='atoc';"},"Linux/Basics/TCP IP.html":{"url":"Linux/Basics/TCP IP.html","title":"TCP IP","keywords":"","body":" TCP/IP模型 TCP/IP模型 Transmission Control Protocol/Internet Protocol 参考引用:关于 TCP/IP，必知必会的十个问题 印象笔记：关于 TCP/IP，必知必会的十个问题 var className='atoc';"},"Linux/Basics/文件目录管理.html":{"url":"Linux/Basics/文件目录管理.html","title":"文件目录管理","keywords":"","body":" 目录与路径 linux目录 目录相关操作: cd, pwd, mkdir，rmdir 环境变量：$PATH 文件目录管理 文件与目录检视: ls 复制 cp, 删除 rm, 移动或更名 mv 文件及文件内容查看 查看文本文档内容: cat, tac, nl, more, less 文本搜索: grep, head, tail, cut， wc, diff 3.文件操作命令-touch, -stat，-file，-tar, -zip， -dd 文件权限 文件权限及归属 chmod 更改文件或目录 读写等权限 1.文件预设权限:-umask 2.档案隐藏属性:-chattr,-lsattr 3.特殊权限:-SUID,-SGID,-SBIT 4.查看文件类型:-file 搜寻命令与文件 1.命令搜索:-which 2.文件名搜寻 权限与命令间的关系 目录与路径 每天一个linux命令（23）：Linux 目录结构 - peida - 博客园 linux目录 路径 说明 / 根目录 /boot 存放内核以及启动所需的文件 /dev 存放设备与接口文件 /etc 存放系统配置文件 /bin 存放必要命令 /home 普通用户的宿主目录，用户数据 /lib 存放必要的运行库 /mnt 存放临时的映射文件系统，通常用来挂载使用 /proc 虚拟文件系统，如系统内核存储进程和网络状态信息 /opt 放置第三方的软件 /srv 一些网络服务的数据文件目录 /root 超级用户的主目录 /sbin 存放系统管理程序 /tmp 存放临时文件 /usr 存放应用程序，命令程序文件，程序库，手册和其他文档 /usr/local 用户自行安装的软件 /usr/share 帮助说明文件，共享文件 /var 默认日志存放目录 目录相关操作: cd, pwd, mkdir，rmdir cd 变换目录( Change Directory) 参数 作用 . 此层目录 .. 上层目录 - 前一个工作目录 ~ 目前用户所有家目录 pwd 显示当前路径(Print Working Directory ) mkdir 建立新目录 mkdir [选项] 目录 -m 配置目录权限-p 建立递归目录 rmdir 删除空目录 环境变量：$PATH [ ] TODO echo $PATH 查看环境变量 文件目录管理 文件与目录检视: ls 参数 作用 -l 查看详细信息,或ll -a 查看全部文件，包括隐藏文件 la -h 查看大小单位为GB,MB,KB等 -i 列出inode号 -n 列出UID与GID而非用户名与组名 -R 列出子目录 -S 按文件大小排序 -t 依时间排序 复制 cp, 删除 rm, 移动或更名 mv cp [选项] 源文件 目标文件 参数 作用 -d 若对象为“链接文件”，则保留该“链接文件”的属性 -P 连同文件属性一起复制过去(备份常用) -r 递归持续复制（用于目录） -a 等价于“dpr”选项 -f 强制执行 -i 覆盖前询问 rm 删除 文件或目录 rm -rf test.txt mv [选项] 源文件或目录 目标文件或目录 -b 若覆盖文件，则覆盖前先进行备份 mv file1 file2 file3 target_path #移动多个文件 mv file_name new_name # 文件更名 文件及文件内容查看 查看文本文档内容: cat, tac, nl, more, less cat 显示全部 cat [选项] [文件] | 参数 | 作用 | | ---- | ----------------------- | | -n | 列出行号,显示空白行号 | | -b | 列出行号,不显示空白行号 | tac 由最后一行开始显示,cat反写 nl 显示内容及行号 more 分页查看 | 按键 | 作用 | | -------------- | ---------------------------------------------------- | | 空格键 (space) | 代表向下翻一页 | | Enter | 代表向下翻 一行 | | / 字符串 | 代表在这个显示癿内容弼中，向下搜寻 字符串 这个关键词 | | :f | 立刻显示出文件名以及目前显示癿行数 | | q | 代表立刻离开 more ，丌再显示该档案内容 | | b 或 [ctrl]-b | 代表往回翻页，丌过这劢作叧对档案有用，对管线无用 | less 和more一样,但是可以往前翻页, more [选项]文件 | 按键 | 作用 | | ---------- | --------------------------------------- | | 空格键 | 向下翻劢一页 | | [pagedown] | 向下翻劢一页 | | [pageup] | 向上翻劢一页 | | /字符串 | 向下搜寻 | | ?字符串 | 向上搜寻 | | n | 重复前一个搜寻 (与 / 或 ? 有关！) | | N | 反复的重复前一个搜寻 (与 / 或 ? 有关！) | | q | 离开 less 这个程序 | tr命令 用于替换文本文件中的字符, tr [原始字符] [目标字符] cat config.config | tr [a-z] [A-Z] # 例如某个文本内容中的英文全部替换为大写 文本搜索: grep, head, tail, cut， wc, diff grep [ ] TODO head 只显示前几行 head [选项] [文件] ail 只显示最后几行 -n 接数字,表示显示几行 tail -f config.config # 持续刷新内容 head -n 10 head -n -10 #不显示最后2行 tail -n +10 #第10行开始显示(不显示最开始9行) cut 按“列”提取文本字符, cut [参数] 文本 参数 作用 -b 以字节为单位进行分割 ,仅显示行中指定直接范围的内容 -c 以字符为单位进行分割 , 仅显示行中指定范围的字符 -d 自定义分隔符，默认为制表符”TAB” -f 显示指定字段的内容 , 与-d一起使用 -n 取消分割多字节字符 cut -d: -f1 /etc/passwd # -f参数来设置需要看的列数 -d参数来设置间隔符号 以冒号(:)为间隔符号的第一列内容 wc命令用于统计指定文本的行数、字数、字节数, wc [参数] 文本 | 参数 | 作用 | | ---- | ------------ | | -l | 只显示行数 | | -w | 只显示单词数 | | -c | 只显示字节数 | diff 用于比较多个文本文件的差异, diff [参数] 文件 diff --brief file_A.txt file_B.txt # 使用diff --brief命令比较，判断文件是否相同 diff -c file_A.txt file_B.txt # 使用带有-c参数的diff命令来描述文件内容具体的不同 3.文件操作命令-touch, -stat，-file，-tar, -zip， -dd touch 修改文档时间与建立新文档, - touch [选项] [文件] | 参数 | 作用 (文件时间) | | ---- | ----------------------------------------- | | -m | 仅修改文件内容的修改时间（mtime） | | -a | 仅修改文件的读取时间(atime) | | -d | 同时修改atime与mtime 使用指定的日期时间 | | | 文件权限或属性的更改时间（ctime） | stat用于查看文件的具体存储信息和时间等信息，stat 文件名 file命令用于查看文件的类型,也可以查看执行程序命, file 文件名 tar 对文件进行打包压缩或解压, tar [选项] [文件] | 参数 | 作用 | | ---- | ---------------------- | | -c | 创建压缩文件 | | -x | 解开压缩文件 | | -t | 查看压缩包内有哪些文件 | | -z | 用Gzip压缩或解压 | | -j | 用bzip2压缩或解压 | | -v | 显示压缩或解压的过程 | | -f | 目标文件名 | | -p | 保留原始的权限与属性 | | -P | 使用绝对路径来压缩 | | -C | 指定解压到的目录 | tar -czvf etc.tar.gz /etc # 压缩 /etc 目录下的文件 tar -xzvf speed.log.tar.gz # 解压 speed.log.tar.gz 文件 -xf tar xzvf etc.tar.gz -C /root/etc #解压到目录中 zip命令 zip 压缩文件名 源文件 #压缩文件zip -r 压缩文件名 源目录 #压缩目录unzip 压缩文件名 #解压缩.zip 文件 dd命令 非纯文本文档: -od ​ od 以二进制方式读取文档内容 文件权限 文件权限及归属 Linux系统中一切都是文件，区分文件类型常见的字符如下所示 参数 作用 - 普通文件 d (directory)目录文件 l （link)链接文件 b (block)块设备文件 c (character)字符设备文件 p (pipe)管道文件 s (socket)套接字文件 [root@cen ~]# ll test -rw-r--r-- 1 root root 28 Apr 9 10:23 test 包含了文件的类型、访问权限、所有者（属主）、所属组（属组）、占用的磁盘大小、修改时间和文件名称等信息。 通过分析可知，该文件的类型为普通文件 所有者权限为可读、可写(rw-) 所属组权限为可读(r--) 除此以外的其他人也只有可读权限(r--) 文件的磁盘占用大小是28字节 最近一次的修改时间为4月9日 10:23分 文件的名称为 test 权限 读 写 执行 读 写 执行 读 写 执行 字符表示 r w x r w x r w x 数字表示 4 2 1 4 2 1 4 2 1 权限分配 所有者 所有者 所有者 所属组 所属组 所属组 其他用户 其他用户 其他用户 chmod 更改文件或目录 读写等权限 https://www.cnblogs.com/peida/archive/2012/11/29/2794010.html chmod [参数] [文件/目录]u：文件所有者， g：文件属组，o：其他用户， a：所有用户 参数 作用 -c 若该文件权限确实已经更改，才显示其更改动作 -f 若该文件权限无法被更改也不显示错误讯息 -v 显示权限变更的详细资 -R 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) chmod a+r files #给其所有添加读权限 chmod -R a+r * #将目前目录下的所有文件与子目录皆设为任何人可读取 chmod o=--- #修改其他用户权限 shmod 777 files #修改文件权限 1.文件预设权限:-umask 2.档案隐藏属性:-chattr,-lsattr 3.特殊权限:-SUID,-SGID,-SBIT 4.查看文件类型:-file 搜寻命令与文件 1.命令搜索:-which 2.文件名搜寻 权限与命令间的关系 var className='atoc';"},"Linux/Basics/用户身份及权限.html":{"url":"Linux/Basics/用户身份及权限.html","title":"用户身份及权限","keywords":"","body":" 文件权限 文件权限及归属 chmod 更改文件或目录 读写等权限 用户管理 用户权限 用户及用户组：useradd， usermod, userdel, groupadd, groupmod, groupdel passwd, chage chown 修改文件或目录的所有者或所属组 su, sudo 文件权限 文件权限及归属 Linux系统中一切都是文件，区分文件类型常见的字符如下所示| 参数 | 作用 | | ---- | ----------------------- | | - | 普通文件 | | d | (directory)目录文件 | | l | （link)链接文件 | | b | (block)块设备文件 | | c | (character)字符设备文件 | | p | (pipe)管道文件 | | s | (socket)套接字文件 | [root@cen ~]# ll test -rw-r--r-- 1 root root 28 Apr 9 10:23 test 包含了文件的类型、访问权限、所有者（属主）、所属组（属组）、占用的磁盘大小、修改时间和文件名称等信息。 通过分析可知，该文件的类型为普通文件 所有者权限为可读、可写(rw-) 所属组权限为可读(r--) 除此以外的其他人也只有可读权限(r--) 文件的磁盘占用大小是28字节 最近一次的修改时间为4月9日 10:23分 文件的名称为 test 权限 读 写 执行 读 写 执行 读 写 执行 字符表示 r w x r w x r w x 数字表示 4 2 1 4 2 1 4 2 1 权限分配 所有者 所有者 所有者 所属组 所属组 所属组 其他用户 其他用户 其他用户 chmod 更改文件或目录 读写等权限 https://www.cnblogs.com/peida/archive/2012/11/29/2794010.html chmod [参数] [文件/目录]u：文件所有者， g：文件属组，o：其他用户， a：所有用户 参数 作用 -c 若该文件权限确实已经更改，才显示其更改动作 -f 若该文件权限无法被更改也不显示错误讯息 -v 显示权限变更的详细资 -R 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) chmod a+r files #给其所有添加读权限 chmod -R a+r * #将目前目录下的所有文件与子目录皆设为任何人可读取 chmod o=--- #修改其他用户权限 shmod 777 files #修改文件权限 用户管理 用户权限 /etc/passwd #用户信息保存文件 /etc/group #用户组信息 cat /etc/passwd 可以查看所有用户的列表 #/bin/bash 表示可以登陆系统 w 可以查看当前活跃的用户列表 cat /etc/group 查看用户组 cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F\":\" '{ print $1\"|\"$3\"|\"$4 }'|mor id centos // 显示指定用户信息 groups centos // 显示用户所在用户所有组 chfn centos // 设置用户资料 finger centos //显示用户详细资料 id 查看uid，gid及归属的用户组 [ ] TODO 通过 用户的身份号码即UID（User IDentification）UID 来区分用户权限级别用户组号码（GID，Group IDentification），一个用户只有一个基本用户组，但是可以有多个扩展用户组 管理员UID为0：系统的管理员用户 系统用户UID为1～999： Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围 普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。UID是不能冲突的 用户及用户组：useradd， usermod, userdel, groupadd, groupmod, groupdel useradd [选项] 用户名 创建新用户 默认的用户家目录会被存放在/home目录中，默认的Shell解释器为/bin/bash，而且默认会创建一个与该用户同名的基本用户组 #创建一个普通用户并指定家目录的路径、用户的UID以及Shell解释器 [root@centos1 ~]# useradd -d /home/linux -u 8888 -s /sbin/nologin lxj [root@centos1 ~]# id lxj uid=8888(lxj) gid=8888(lxj) groups=8888(lxj) useradd -g group_name user_name #添加用户并指定用户组 usermod -g new_group old_group #切换用户组 userdel user_name #删除用户， -r 删除用户及其目录 参数 作用 -d 指定用户的家目录（默认为/home/username） -e 账户的到期时间，格式为YYYY-MM-DD. -u 指定该用户的默认UID -g 指定一个初始的用户基本组（必须已存在） -G 指定一个或多个扩展用户组 -N 不创建与用户同名的基本用户组 -s 指定该用户的默认Shell解释器 usermod 修改用户属性 usermod [参数] 用户名 usermod -G root lxj #将用户lxj加入root用户组中 usermod -u 1234 lxj #修改用户lxj的uid号，还可用-g修改用户基本组id，用-G修改扩展组id 参数 作用 -c 填写用户账户的备注信息 -d -m 参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去 -e 账户的到期时间，格式为YYYY-MM-DD -g 变更所属用户组 -G 变更扩展用户组 -L 锁定用户禁止其登录系统 -U 解锁用户，允许其登录系统 -s 变更默认终端 -u 修改用户的UID userdel 删除用户 # userdel [选项] 用户名 userdel -f lxj #强制删除用户lxj -f userdel -r lxj #删除用户及用户家目录 -r groupadd 添加用户组 [root@centos1 ~]# groupadd lxj groupadd -g 888 name #创建用户组及用户组编号 groupmod [选项] 组名 修改用户组属性 groupmod -n new old #修改用户组名 groupmod -g 1688 name #修改用户组编号 groupdel name #删除用户组，不过先要删除用户组里面的用户 groupdel 删除组 passwd, chage passwd 修改用户密码 passwd [选项] 用户名 #修改用户密码、过期时间、认证信息 passwd lxj #修改用户lxj的密码 passwd -l lxj #锁定用户lxj，禁止该用户登录，比如休假等时间控制权限 passwd -u lxj #解除锁定登录 passwd -S lxj #查看用户时候被锁定登录 参数 作用 -l 锁定用户，禁止其登录 -u 解除锁定，允许用户登录 --stdin 允许通过标准输入修改用户密码，如echo \"NewPassWord\" \\ passwd --stdin Username -d 使该用户可用空密码登录系统 -e 强制用户在下次登录时修改密码 -S 显示用户的密码是否被锁定，以及密码所采用的加密算法名称 chage 修改用户密码有效期限 chown 修改文件或目录的所有者或所属组 # chown [参数] [所有者][:所属组] 文件或目录名 chown lxj:lxj files.sh #改变文件所有者和群组都为lxj chown root:files.sh #改变文件所有者和群组都为root chown :root files.sh #改变文件群组为root chown -R -v root:lxj folder #改变目录及其子目录里面所有文件的所有者及群组 #-R 指定目录及其子目录下所有文件， -v 显示详细处理信息 chgrp 更改文件用户组。 umask 显示或设置权限掩码。 su, sudo su 切换用户身份 su - root # 切换用户身份，'-'表示相应的环境变量一起切换 #普通用户切换到root用户，有可能暴露root用户密码，不安全，建议用sudo服务 var className='atoc';"},"Linux/Basics/磁盘管理与文件系统.html":{"url":"Linux/Basics/磁盘管理与文件系统.html","title":"磁盘管理与文件系统","keywords":"","body":" 磁盘管理 磁盘管理 参考 有关磁盘与文件系统的命令（16个） mount 挂载文件系统。 umount 卸载文件系统。 fsck 检查并修复Linux文件系统。 dd 转换或复制文件。 dumpe2fs 导出ext2/ext3/ext4文件系统信息。 dump ext2/3/4文件系统备份工具。 fdisk 磁盘分区命令，适用于2TB以下磁盘分区。 parted 磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。 mkfs 格式化创建Linux文件系统。 partprobe 更新内核的硬盘分区表信息。 e2fsck 检查ext2/ext3/ext4类型文件系统。 mkswap 创建Linux交换分区。 swapon 启用交换分区。 swapoff 关闭交换分区。 sync 将内存缓冲区内的数据写入磁盘。 resize2fs 调整ext2/ext3/ext4文件系统大小。 常见的硬件设备及其文件名称 硬件设备 文件名称 IDE设备 /dev/hd[a-d] SCSI/SATA/U盘 /dev/sd[a-z] virtio设备 /dev/vd[a-z] 软驱 /dev/fd[0-1] 打印机 /dev/lp[0-15] 光驱 /dev/cdrom 鼠标 /dev/mouse 磁带机 /dev/st0或/dev/ht0 主分区或扩展分区的编号从1开始，到4结束 逻辑分区编号从5开始 /dev/sda5 表示:这是系统中第一块被识别到的硬件设备中分区编号为5的逻辑分区的设备文件,并不能判断sda设备上上有5个分区 Linux只是把每个文件的权限与属性记录在inode中，而且每个文件占用一个独立的inode表格，该表格的大小默认为128字节，里面记录着如下信息： 该文件的访问权限（read、write、execute）； 该文件的所有者与所属组（owner、group）； 该文件的大小（size）； 该文件的创建或内容修改时间（ctime）； 该文件的最后一次访问时间（atime）； 该文件的修改时间（mtime）； 文件的特殊权限（SUID、SGID、SBIT）； 该文件的真实数据地址（point）。 mount命令用于挂载文件系统， mount 文件系统 挂载目录 -a 挂在所有在/etc/fstab中定义的文件系统 -t 指定文件系统类型 mount /dev/sdb2 /backup #设备/dev/sdb2挂载到/backup目录 umount命令用于撤销已经挂载的设备文件 umount [挂载点/设备文件] umount /dev/sdb2 var className='atoc';"},"Linux/Basics/网络服务管理.html":{"url":"Linux/Basics/网络服务管理.html","title":"网络服务管理","keywords":"","body":" 网络服务概述 网络配置 TCP Wrappers(简单防火墙) 网络服务概述 网关 Ip 等概念 https://www.cnblogs.com/iceJava/p/5372033.html 网络服务：是指一些在网络上运行的、面向服务的软件模块 网络服务的标准：可以使用各种协议通过网络进行远程访问的软件模 块（常见协议http/ftp/telnet/smtp等）（网络，文本，登陆，邮件） NDS 域名解析 如何保证数据的完整性：rsync 镜像备份 用户量增大，网站怎么处理：将mysql单独放在一个服务器上，再将apache单独放出来 非运维人员如何上传资源： 单独搭建ftp服务，开放某个文件夹权限，给编程人员进行上传 如何获取用户访问量及服务器故障等问题： zabbix等监控服务 netstat -antp 查看网络状态 centos 6.x/7.x 对比 对比 centos 6.x centos 7.x 文件系统 EXT4，Ext4的单个文件系统容量达到1EB，单个文件大小则达到16TB XFS，XFS默认支持8EB减1字节的单个件系统，最大可支持的文件大小为9EB，最大文件系统尺寸为18EB 防火墙 iptables firewalld (主要还是用iptables) 内核版本 2．6．x-x 3.10．x-x 默认数据库 MYSQL MarialDB 时间同步ntpq -p chronyc sources 修改时区 /etc/sysconfig/clock timedatectl set-timezone Asiz/Shanghai 修改语言 /etc/sysconfig/i18n localectl set-locale LANG=zh_CN.UTF-8 主机名 配置文件为/etc/sysconfig/network(永久设置) /etc/hostname(永久配置)，hostnamectl set-hostname localhost 网络服务管理 --- --- 启动服务 service 服务名 start systemctl start 服务名 关闭服务 service 服务名 stop systemctl stop 服务名 重启服务 service 服务名 restart systemctl restart 服务名 查看服务状态 service 服务名 status systemctl status 服务名 查看所有服务状态 service --status-all systemctl list-units 设置服务自启动 chkconfig 服务名 on systemctl enable 服务名 设置服务不自启动 chkconfig 服务名 off systemctl disable 服务名 查看所有服务自启动状态 chkconfig --list systemctl list-unit-files 网络设置 --- --- 网卡名 eth0 ens33 网络配置命令 ifconfig/setup ip/nmtui 网络服务 默认使用network服务 NetworkManager服务(network作为备用) 网络配置 nmtui 命令配置 网卡配置文件目录：/etc/sysconfig/network-scripts/ifcfg-ens33 ifcfg-eth0表示第一块网卡，ifcfg-eth1 第二块依次往下推 配置文件内容： #选项需要大写，小写不生效 TYPE=Ethernet #网卡类型 DEVICE=ens33 #物理设备名 NAME=ens33 #网卡名称 BOOTPROTO=static #连接方式（不使用协议none/动态dhcp/静态static) ONBOOT=yes #是否开机加载 IPADDR=192.168.137.128 #IP地址 NETMASK=255.255.255.0 #子网掩码(cents7里面配置PREFIX=24) GATEWAY=192.168.12.1 #网关 DNS1=8.8.8.8 #DNS DNS2=10.82.1.4 #备用DNS(可不写) 网卡配置完毕，重启网卡 /etc/init.d/network restart # 或者 systemctl restart network #重启网络服务（生产环境两张网卡慎用） ifdown ens33;ifup ens33 #重启指定网卡 创建网络会话，使用nmcli命令来管理Network Manager服务 nmcli connection show nmcli con show ens33 [ ] TODO 绑定两张网卡服务 网络地址：互联网协议地址(IP地址）为互联网上每一个网络或主机分配一个逻辑地址，IP地址工作在络层 IP的分类：IPV4IPV6 物理地址：物理地址(MAC地址）为每一个设各设置一个固定的硬件地址,MAC地址工作在链路层 MAC地址：00-23-5A-15-99-42 常见的网络协议及端口 常见的协议 应用层协议：FTP、HTTP、SMTP、Telnet、DNS等 (运维需掌握) 传输层协议：TCP、UDP等 网络层协议：IP、ICMP、ARP等 数据链路层协议：PPP协议等，pop拨号，交换机 物理层：不常用 常见网络端口： 配置文件 /etc/services |端口|服务|备注| |---|---|---| |20/21|ftp服务|文件功能| |22|ssh服务|安全远程管理| |23|telnet服务(不安全,基本不用)|不安全远程管理| |25|smtp:简单邮件传输协议|发信| |465|smtp(ssl)加密|发信| |110|pop3:邮局协议(只能收发纯文本)|收信| |143|imap4|收信| |993|imap4(ssl)加密|收信| |80|www服务(http://)|网页访问| |443|www服务(https://)|加密网页访问| |53|NDS端口|域名解析端口| |3306|mysql端口|数据库连接端口| 路由静态路由：配置麻烦，消耗资源小，优先级较高，适合局域网，设备少的网络动态路由：消耗资源较多，不需要额外指定 不同网段数据转发 路由选择 网关 不同网段数据转发 路由选择 默认路由 NAT转换 route -n #查看系统中的路由表信息 route add default gw #临时添加网关 route del default gw #临时删除网关 vim /etc/sysconfig/network-scripts/ifcfg-ens33 #永久修改网关 常用网络命令 ping 网络联通性测试命令 nslookup DNS域名解析测试命令 yum -y install bind-utils DNS配置文件 #局部：/etc/sysconfig/network-scripts/ifcfg-ens33 #全局：/etc/resolv.conf (nmeserver ip)优先级更高 #相关配置文件 /etc/hosts netstat 查看系统的网络连接状态，路由信息，接口信息 yum -y install net-tools |参数|作用| |---|---| |-a|显示所有活动连接| |-n|以数字形式显示| |-t|查看TCP协议相关| |-u|查看UDP协议相关| |-p|显示PID和进程名| |-l|监听| traceroute 追踪数据包在网络上的传输时的全部路径 yum install -y traceroute 测试从当前主机到目的主机之间经过的网络节点数，用于追踪数据包在网络上传输时的全部路径，它默认发送的数据包大小是40字节，默认使用ICMP协议(该命令在使用NAT模式时无法实现效果，切换桥接模式) |参数|作用| |---|---| |-p| 使用UDP端口进行测试，默认端口为33434| |-q 3 |指定测试时发送的数据包个数（即测试次数）| |-n|以IP的方式进行连接测试，避开DNS的解析| arp 地址解析协议，将ip地址解析成MAC地址 -a 查看所有 -d ip地址，删除某条ARP记录 nmap 网络探测扫描命令 -sP 探测某网段内有哪些主机是存活的 -sT 探测某主机上开启了哪些TCP端口 nmap -sP 192.168.88.1/24 nmap -sT 192.168.88.100 ifconfig 命令 [ ] TODO TCP Wrappers(简单防火墙) 请求进来，经过TCP Wrappers,首先在/etc/hosts.allow文件中查找规则匹配，如果找到匹配规则，则判断批准或拒绝访问，如果没有找到匹配规则，则会在/etc/hosts.deny文件中找匹配规则，如果找到，则判断批准或拒绝访问，如果两个都没找到，则默认允许。 1.优先查看hosts.allow,匹配即停止。 2.允许个别，拒绝所有：hosts.allow文件添加允许的策略，hosts.deny文件添加all 3.拒绝个别，允许所有：hosts.allow文件为空，hosts.deny文件添加单个拒绝的策略 TCP Wrapper 使用 配置文件编写规则： service_list@host: client_list service_list:是程序（服务）的列表，可以是多个，多个时，使用。隔开 @host:设置允许或禁止他人从自己的哪个网口进入。这一项不写，就代表全部。 client_list:是访问者的地址，如果需要控制的用户较多，可以使用空格或。隔开。 格式如下： 基于IP地址：192.168.88.1 192.168.88. 基于主机名：ww.baidu.com .baidu.com 较少用。 基于网络/掩码：192.168.0.0/255.255.255.0 内置ACL： ALL(所有主机), LOCAL(本地主机) 案例： 拒绝单个IP使用ssh远程连接： 配置文件： hosts.allow:空着 hosts.deny: sshd:193168.88.20 拒绝某一网段使用ssh送程连接： hosts.allow:空着 hosts.deny: sshd:192.168.88. 仅允许某一IP使用ssh远程连接： hosts.allow: ssh:192.168.88.20 hosts.deny: sshd:ALL .sample 文件，为模板文件 var className='atoc';"},"Linux/DevOps/Ansible/ansible.html":{"url":"Linux/DevOps/Ansible/ansible.html","title":"Ansible","keywords":"","body":"《Python自动化运维 技术与最佳实践》 第二部分 第9章 var className='atoc';"},"Linux/DevOps/Git相关/GitBook使用.html":{"url":"Linux/DevOps/Git相关/GitBook使用.html","title":"GitBook使用","keywords":"","body":" GitBook 使用 安装 运行 目录文件 GitBook 命令 GitBook 配置 插件 目录导航 根据文件自动生成目录。 将书籍分成几个部分 左侧导航栏目录折叠 使左侧目录默认关闭 使左侧章节目录可以折叠图标变小 侧边导航栏宽度可调节 添加页面内右侧导航 页面操作 待办事项 隐藏元素 高级搜索 回到顶部按钮 阅读量计数 复制代码 弹出大图 页面信息修改 标题颜色 github地址添加 插入logo 修改标题栏图标 添加页脚版权 分享文档 文档及帮助 制作知识库或者帮助中心 GitBook写API文档 book.json 参考 发布 github pages 个人网站 GitBook插件列表 GitBook 使用 安装 先安装nodejs，用npm工具安装gitbook npm install -g gitbook-cli gitbook init 初始化失败处理，报错信息：TypeError: cb.apply is not a function 运行 gitbook build #生成静态网页，放入_book文件夹，可以上传 gitbook serve [--port 2333] #可指定端口 #生成静态网页，并运行服务器，预览书籍地址http://localhost:4000/ gitbook build/serve 失败处理 报错信息：Error: ENOENT: no such file or directory 目录文件 README.md 包含电子书的简介 SUMMARY.md 包含电子书目录结构 # Summary * [Introduction](README.md) * [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) * [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) GitBook 命令 gitbook init //初始化目录文件 gitbook help //列出gitbook所有的命令 gitbook --help //输出gitbook-cli的帮助信息 gitbook build //生成静态网页 gitbook serve //生成静态网页并运行服务器 gitbook build --gitbook=3.2.3 //生成时指定gitbook的版本, 本地没有会先下载 gitbook ls //列出本地所有的gitbook版本 gitbook ls-remote //列出远程可用的gitbook版本 gitbook fetch 3.2.3 //安装对应的gitbook版本 gitbook update //更新到gitbook的最新版本 gitbook uninstall 3.2.3 //卸载对应的gitbook版本 gitbook build --log=debug //指定log的级别 gitbook builid --debug //输出错误信息 GitBook 配置 在初始化目录创建book.json文件，对GitBook进行配置 { \"title\": \"Note\", //设置书本的标题 \"author\": \"LXJ\", //作者的相关信息 \"description\": \"笔记整理\", //本书的简单描述 \"language\": \"zh-hans\", //配置语言,使用简体中文,或en \"gitbook\": \"3.2.3\", // 指定版本，或 \"gitbook\":\">=3.1.0\" \"root\": \".\", //指定存放 GitBook 文件（除了 book.json）的根目录 \"links\": { //在左侧导航栏添加链接信息 \"sidebar\": { \"Home\": \"https://app.gitbook.com/@lxianjin/spaces\" } }, \"styles\": \" \", //自定义页面样式 \"plugins\": [ \"chapter-fold\" ], //插件 \"pluginsConfig\": { //配置插件的属性 } } 插件 插件添加到book.json文件plugins中，执行gitbook install进行安装 Gitbook默认带有5个插件：highlight, search, sharing, font-settings, livereload 目录导航 根据文件自动生成目录。 \"summary\" 如果需要自定义，生成一遍之后，建议去掉该插件。 将书籍分成几个部分 \"multipart\" 左侧导航栏目录折叠 \"chapter-fold\" 折叠左侧导航栏目录，无法知道整本书的结构，有利有弊 使左侧目录默认关闭 \"expandable-chapters\" 使左侧章节目录可以折叠图标变小 \"expandable-chapters-small\" 侧边导航栏宽度可调节 \"splitter\" 添加页面内右侧导航 \"atoc\" 页首需添加 ！--toc-->,toc前后各一个空格 { \"plugins\": [ \"atoc\" ], \"pluginsConfig\": { \"atoc\": { \"addClass\": true, \"className\": \"atoc\" } } } 页面操作 待办事项 \"todo\" 隐藏元素 \"hide-element\" 如下，隐藏左侧导航栏的Link：Published with GitBook { \"plugins\": [ \"hide-element\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [ \".gitbook-link\" ] } } } 高级搜索 \"search-pro\" 支持中英文,需将内置搜索插件禁用 { plugins: [ \"-lunr\", \"-search\", \"search-pro\" ] } 回到顶部按钮 \"back-to-top-button\" 在右下角添加一个按钮，可回到顶部 阅读量计数 \"pageview-count\" 记录每个文章页面被访问的次数 复制代码 \"code\" 可使代码区域的右上角添加一个复制按钮 弹出大图 \"popup\" 点击可在新窗口展示图片 页面信息修改 标题颜色 \"theme-comscore\" ComScore 是一个彩色主题，可以为各级标题添加不同的颜色，更容易区分各级标题。 github地址添加 \"github\" 在页面右上角有个 github 小图标 ，点击小图标跳转到对应的Github地址。 { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/lxj4713/testpages\" } } } 插入logo \"insert-logo\" 修改标题栏图标 \"custom-favicon\" 添加页脚版权 \"tbfed-pagefooter\" 在每个文章下面标注版权信息和文章时间 { \"plugins\": [ \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\": \"\", //写版权信息 \"modify_label\": \"该文章的修订时间\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } 分享文档 \"sharing-plus\" { \"plugins\": [ \"-sharing\", \"sharing-plus\" ], \"pluginsConfig\": { \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] } } } 文档及帮助 [ ] TODO 制作知识库或者帮助中心 \"theme-faq\" GitBook写API文档 \"theme-api\" { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"theme\": \"dark\" } } } book.json 参考 { \"title\": \"Note\", \"author\": \"LXJ\", \"language\": \"zh-hans\", \"plugins\": [ \"summary\", \"atoc\", \"multipart\", \"back-to-top-button\", \"chapter-fold\", \"expandable-chapters\", \"expandable-chapters-small\", \"hide-element\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"popup\", \"-sharing\", \"sharing-plus\", \"todo\", \"github\", \"theme-comscore\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [ \".gitbook-link\" ] }, \"atoc\": { \"addClass\": true, \"className\": \"atoc\" }, \"github\": { \"url\": \"https://github.com/lxj4713/testpages\" } } } 发布 github pages 托管到github pages上 # 生成静态网站 $ gitbook build # 复制到项目根目录 $ cp -r _book/* . # 添加到本地版本库 $ git add . $ git commit -m \"publish\" # 推送到远程仓库 $ git push origin master 个人网站 GitBook插件列表 - `mygitalk` 基于gitalk的评论插件 ➡️ https://github.com/snowdreams1006/gitbook-plugin-mygitalk - `theme-default` GitBook的默认主题 ➡️ https://github.com/GitbookIO/theme-default - `autotheme` 自动换肤插件 ➡️ https://github.com/willin/gitbook-plugin-autotheme - `sharing` 默认的分享插件 ➡️ https://github.com/GitbookIO/plugin-sharing - `fontsettings` 默认的字体、字号、颜色设置插件 ➡️ https://github.com/GitbookIO/plugin-fontsettings - `highlight` 默认的代码高亮插件，通常会使用 prism 来替换 ➡️ https://github.com/GitbookIO/plugin-highlight - `search` 默认搜索插件 ➡️ https://github.com/GitbookIO/plugin-search - `search-plus` 支持中文搜索插件 ➡️ https://github.com/lwdgit/gitbook-plugin-search-plus - `prism` 基于 [Prism](http://prismjs.com/) 的代码高亮 ➡️ https://github.com/gaearon/gitbook-plugin-prism - `favicon` 更改网站的 favicon.ico ➡️ https://github.com/menduo/gitbook-plugin-favicon - `github` 在右上角显示 github 仓库的图标链接 ➡️ https://github.com/GitbookIO/plugin-github - `github-buttons` 显示 github 仓库的star和fork按钮 ➡️ https://github.com/azu/gitbook-plugin-github-buttons - `splitter` 在左侧目录和右侧内容之间添加一个可以拖拽的栏，用来调整两边的宽度 ➡️ https://github.com/yoshidax/gitbook-plugin-splitter - `copy-code-button` 为代码块添加复制的按钮 ➡️ https://github.com/WebEngage/gitbook-plugin-copy-code-button - `tbfed-pagefooter` 自定义页脚，显示版权和最后修订时间 ➡️ https://github.com/zhj3618/gitbook-plugin-tbfed-pagefooter - `expandable-chapters` 收起或展开章节目录中的父节点 ➡️ https://github.com/DomainDrivenArchitecture/gitbook-plugin-expandable-chapters - `expandable-chapters-small` 比较好的折叠侧边栏 ➡️ https://github.com/lookdczar/gitbook-plugin-expandable-chapters-small-auto - `book-summary-scroll-position-saver` 自动保存左侧目录区域导航条的位置 ➡️ https://github.com/yoshidax/gitbook-plugin-book-summary-scroll-position-saver - `ga` 添加 Google 统计代码 ➡️ https://github.com/GitbookIO/plugin-ga - `sitemap` 生成站点地图 ➡️ https://github.com/GitbookIO/plugin-sitemap - `baidu` 使用百度统计 ➡️ https://github.com/poppinlp/gitbook-plugin-baidu - `Donate` Gitbook 捐赠打赏插件 ➡️ https://github.com/willin/gitbook-plugin-donate - `anchors` 标题带有 github 样式的锚点 ➡️ https://github.com/rlmv/gitbook-plugin-anchors - `anchor-navigation-ex` 插件锚导航-EX ➡️ https://github.com/zq99299/gitbook-plugin-anchor-navigation-ex - `theme-api` 编写 API 文档 ➡️ https://github.com/GitbookIO/theme-api - `katex` 使用KaTex进行数学排版 ➡️ https://github.com/GitbookIO/plugin-katex - `editlink` 内容顶部显示编辑本页链接 ➡️ https://github.com/zhaoda/gitbook-plugin-editlink - `ad` 在每个页面顶部和底部添加广告或任何自定义内容 ➡️ https://github.com/zhaoda/gitbook-plugin-ad - `image-captions` 抓取内容中图片的`alt`或`title`属性，在图片下面显示标题 ➡️ https://github.com/todvora/gitbook-plugin-image-captions - `chart` 使用 C3.js 图表 ➡️ https://github.com/csbun/gitbook-plugin-chart - `styles-sass` 使用 SASS 替换 CSS ➡️ https://github.com/GitbookIO/plugin-styles-sass - `styles-less` 使用 LESS 替换 CSS ➡️ https://github.com/GitbookIO/plugin-styles-less - `disqus` 添加 disqus 评论插件 ➡️ https://github.com/GitbookIO/plugin-disqus - `latex-codecogs` 使用数学方程式 ➡️ https://github.com/GitbookIO/plugin-latex-codecogs - `mermaid` 使用流程图 ➡️ https://github.com/JozoVilcek/gitbook-plugin-mermaid - `atoc` 插入 TOC 目录 ➡️ https://github.com/willin/gitbook-plugin-atoc - `ace` 插入代码高亮编辑器 ➡️ https://github.com/ymcatar/gitbook-plugin-ace - `sectionx` 分离各个段落，并提供一个展开收起的按钮 ➡️ https://github.com/ymcatar/gitbook-plugin-sectionx - `mcqx` 交互式多选插件 ➡️ https://github.com/ymcatar/gitbook-plugin-mcqx - `include-codeblock` 通过引用文件插入代码 ➡️ https://github.com/azu/gitbook-plugin-include-codeblock - `fbqx` 使用填空题 ➡️ https://github.com/Erwin-Chan/gitbook-plugin-fbqx - `spoiler` 隐藏答案，当鼠标划过时才显示 ➡️ https://github.com/ymcatar/gitbook-plugin-spoiler - `anchor-navigation` 锚点导航 ➡️ https://github.com/yaneryou/gitbook-plugin-anchor-navigation - `youtubex` 插入 YouTube 视频 ➡️ https://github.com/ymcatar/gitbook-plugin-youtubex - `redirect` 重定向页面跳转 ➡️ https://github.com/ketan/gitbook-plugin-redirect - `duoshuo` 使用多说评论 ➡️ https://github.com/codepiano/gitbook-plugin-duoshuo - `jsfiddle` 插入 JSFiddle 组件 ➡️ https://github.com/Mavrin/gitbook-plugin-jsfiddle - `jsbin` 插入 JSBin 组件 ➡️ https://github.com/jcouyang/gitbook-plugin-jsbin - `Advanced Emoji` 支持emoji表情 ➡️ https://github.com/codeclou/gitbook-plugin-advanced-emoji - `Puml` 使用 PlantUML 展示 uml 图 ➡️ https://github.com/GitbookIO/plugin-puml - `Graph` 使用 function-plot 绘制数学函数图 ➡️ https://github.com/cjam/gitbook-plugin-graph - `Todo` 添加 Todo 功能 ➡️ https://github.com/ly-tools/gitbook-plugin-todo - `include-csv` 展示 csv 文件内容 ➡️ https://github.com/TakuroFukamizu/gitbook-plugin-include-csv - `musicxml` 支持 musicxml 格式的乐谱渲染 ➡️ https://github.com/ymcatar/gitbook-plugin-musicxml - `versions-select` 添加版本选择的下拉菜单，针对文档有多个版本的情况 ➡️ https://github.com/prescottprue/gitbook-plugin-versions-select - `rss` 添加 rss 订阅功能 ➡️ https://github.com/denysdovhan/gitbook-plugin-rss - `multipart` 将书籍分成几个部分 ➡️ https://github.com/citizenmatt/gitbook-plugin-multipart - `url-embed` 嵌入动态内容 ➡️ https://github.com/basilvetas/gitbook-plugin-url-embed 参考：gitbook 码谱教程:https://www.mapull.com/gitbook/default/ 12个插件 https://segmentfault.com/a/1190000019473512 https://www.bookstack.cn/read/yangzh-gitbook/1799c1a766dfe1fe.md https://www.bookstack.cn/read/gitbook-use-3.2.3/plugins.md var className='atoc';"},"Linux/DevOps/Git相关/Git使用.html":{"url":"Linux/DevOps/Git相关/Git使用.html","title":"Git使用","keywords":"","body":" Git基础 远程仓库 Git 分支 远程分支 GitHub Git基础 安装 linux安装git yum install -y git 源码安装 wget 配置 检查配置信息,及查看配置所在文件夹 git config --list git config --list --show-origin 配置用户信息 #设置本地仓库的用户名和邮箱，用于关联远端 git config --golbal user.name \"lxj4713\" git config --golbal user.email \"lxianjin@foxmail.com\" 创建版本仓库 git init # 初始化本地仓库 暂存文件 git git add . git add * 查看当前文件状态 git status git status -s # 简化输出 查看修改 git diff # 查看尚未暂存的文件更新了哪些部分 git diff --staged #对比已暂存文件和最后一次提交的差异 git diff --cached # 查看已暂存起来的变化 忽略文件 .gitignore 查看提交历史 git log git log --stat #简略统计 详细输出参考：git log 提交 git commit -m \"提交说明\" 撤销操作 git commit --amend # 撤销最近一次的提交 git commit --amend -m \"跟正信息说明\" 取消暂存的文件 git reset HEAD ... 撤销对文件的修改 git checkout 会使文件在本地所有的修改都消失 git checkout -- 远程仓库 查看远程仓库 git remote [-v] #显示简写和对应的URL 添加远程仓库 git clone自行添加 添加一个远程Git仓库，同时指定一个方便的简写 git reomote add 从远程仓库中抓取与拉取 从远程拉取所有还没有的数据，也会有拥有所有分支的引用，可以查看或合并 git fetch git fetch不会自动合并或修改当前的工作，需要手动合并到当前工作 git pull 抓取后合并，TODO 推送到远程仓库 git push git push origin master 查看某个远程仓库 git remote show origin 远程仓库的重命名和移除 git remote rename lxj new_lxj # 重命名 git remote remove lxj # 移除远程仓库 标签 列出标签 git tag -l 或 --list git tag git tag -l \"v1.1.0\" 更多标签操作：git文档-打标签 Git 分支 创建分支 git branch lxj 切换分支 git checkout lxj git checkout -b lxj #创建并切换到新分支 合并分支 git merge lxj 合并分支遇到冲突时 contact : email.support@github.com ======= please contact us at support@github.com >>>>>>> iss53:index.html 这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容 解决完所有文件里的冲突后，git add重新提交 分支合并之变基：git文档：变基 分支管理 git branch lxj -v #查看分支最后一次提交 查看哪些分支已经合并到当前分支 $ git branch --merged lxj * master 如上，lxj分支已经合并到master当前分支了，分支名字前没有*号的分支，可以删除掉 如：git branch -d 查看包含未合并工作的分支 git branch --no-merged 分支开发工作流 master 完全稳定的分支 devlop或者next平行分支，用来做后续开发或者测试稳定性 短期分支 远程分支 推送 推送到远程分支lxj git push origin lxj 推送本地的lxj分支，将其作为远程仓库的remote_lxj分支 git push origin lxj:romote_lxj 拉取 git pull git fetch git merge 删除远程分支 git push origin --delete remote_lxj SSH 公钥 .pub 公钥 另外就是私钥 ssh-keygen id_dsa id_ras Git服务器 部署自己的Git服务器(参考Git文档：服务器上的Git) 或者使用GitLab(参考Git文档) [ ] TODO 查看git相关工作流程Git文档第5章 GitHub 详细问题见:GitHub 文档 测试SSH连接 ssh -T git@github.com var className='atoc';"},"Linux/DevOps/Supervisor-Linux上的后台进程管理工具.html":{"url":"Linux/DevOps/Supervisor-Linux上的后台进程管理工具.html","title":"Supervisor Linux上的后台进程管理工具","keywords":"","body":" http://www.bjhee.com/supervisor.html var className='atoc';"},"Linux/Environment/ZSH oh-my-zsh 使用.html":{"url":"Linux/Environment/ZSH oh-my-zsh 使用.html","title":"ZSH Oh My Zsh 使用","keywords":"","body":" zsh介绍 zsh 及 oh my zsh安装 配置文件 oh my zsh主题配置及自定义修改 oh my zsh 插件配置 更新/卸载 oh my zsh 相关参考说明 zsh介绍 zsh 是一款功能强大的 shell 软件，它可以兼容 bash，并且提供了很多高效的改进。它是Linux里最庞大的一种shell，它有84个内部命令，也提供了更为强大的功能: 1.更好的自动补全 2.更好的文件名展开 3.丰富的插件 4.强大的定制性 但是由于配置过于复杂，一般情况下，我们不会使用该shell，直到「oh my zsh」的出现。 zsh 及 oh my zsh安装 yum install zsh -y #zsh安装 chsh -s /bin/zsh #切换系统shell为zsh cat /etc/shells #查看shell #curl或wget安装 oh my zsh sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" sh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\" 配置文件 #切换shell为zsh后之前的环境变量就会失效 vim .zshrc #修改zsh配置，可添加之前的环境变量 # User configuration source ~/.bash_profile source .zshrc #修改后使配置生效 oh my zsh主题配置及自定义修改 ls ~/.oh-my-zsh/themes #查看已有主题 echo $ZSH_THEME #查看当前主题 vim ~/.zshrc ZSH_THEME=\"robbyrussell\" #修改配置文件.zshrc中主题配置项,也可设置为随机random 默认的 'robbyrussell'主题就已经很好，但缺少绝对目录路径和用户名的区分，可自定义主题文件robbyrussell.zsh-theme 为了避免oh-my-zsh的更新版本和自己修改的有冲突，最好不要修改原配置文件，可将其拷贝并重新命名为自己的主题文件myrobbyrussell.zsh-theme，并对其修改 vi ~/.oh-my-zsh/themes/robbyrussell.zsh-theme #修改 robbyrussell 主题的配置文件 # $USER 添加终端用户名及修改为绝对路径$PWD PROMPT=\"%(?:%{$fg_bold[green]%}$USER ➜ :%{$fg_bold[red]%}$USER ➜ )\" PROMPT+=' %{$fg[cyan]%}[$PWD]%{$reset_color%} $(git_prompt_info)' 目前采取做法是，配置不同的颜色来加以区分root及其他用户 (更多主题方案) oh my zsh 插件配置 ls ~/.oh-my-zsh/plugins #查看已存在的插件 zsh-autosuggestions #根据历史输入指令的记录即时的提示 git clone https://github.com/zsh-users/zsh-autosuggestions.git #插件下载 zsh-syntax-highlighting #命令高亮插件，正确的拼写会是绿色标识,否则是红色，路径带有下划线时表示可用路径 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git #插件下载 plugins=(git zsh-autosuggestions zsh-syntax-highlighting) #修改配置文件.zshrc中插件配置项 source ~/.zshrc #更新配置，使插件生效 更新/卸载 oh my zsh vim ~/.zshrc disable_update_prompt = true #自动升级不提示，zsh默认会提示升级 disable_auto_update = true #禁用自动升级 upgrade_oh_my_zsh #手动更新 uninstall_oh_my_zsh zsh #卸载oh-my-zsh 相关参考说明 local ret_status=\"%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ )\" PROMPT='${ret_status} %{$fg[cyan]%}%~%{$reset_color%} $(git_prompt_info)' ZSH_THEME_GIT_PROMPT_PREFIX=\"%{$fg_bold[blue]%}git:(%{$fg[red]%}\" ZSH_THEME_GIT_PROMPT_SUFFIX=\"%{$reset_color%} \" ZSH_THEME_GIT_PROMPT_DIRTY=\"%{$fg[blue]%}) %{$fg[yellow]%}✗\" ZSH_THEME_GIT_PROMPT_CLEAN=\"%{$fg[blue]%})\" #那个%{$fg[cyan]%}%c%{$reset_color%}中的%c就是罪魁祸首，是当前文件夹名的意思，我们把它修改为[$PWD]，整个也就变成了%{$fg[cyan]%}[$PWD]%{$reset_color%} #$PWD是终端自带变量，值为当前路径，我们做的只是把它取出来而已 PROMPT='%{$fg[green]%}%m@%{$fg[magenta]%}%(?..%?%1v)%n:%{$reset_color%}%{$fg[cyan]%}%~#' PROMPT='%{$fg_bold[red]%}-> %{$fg_bold[green]%}%p%{$fg[cyan]%}%d %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%}% %{$reset_color%}~#:' PROMPT='%{$fg_bold[red]%}-> %{$fg_bold[green]%}%p%{$fg[cyan]%}%d %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%}% %{$fg[magenta]%}%(?..%?%1v)%{$reset_color%}~#: ' PROMPT='%{$fg_bold[red]%}-> %{$fg_bold[magenta]%}%n%{$fg_bold[cyan]%}@%{$fg[green]%}%m %{$fg_bold[green]%}%p%{$fg[cyan]%}%~ %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%}% %{$fg[magenta]%}%(?..%?%1v)%{$fg_bold[blue]%}? %{$fg[yellow]%}# ' code info %T 系统时间（时：分） %* 系统时间（时：分：秒） %D 系统日期（年-月-日） %n 你的用户名 %B - %b 开始到结束使用粗体打印 %U - %u 开始到结束使用下划线打印 %d 你目前的工作目录 %~ 你目前的工作目录相对于～的相对路径 %M 计算机的主机名 %m 计算机的主机名（在第一个句号之前截断） %l 你当前的tty %n 登录名 var className='atoc';"},"Linux/Environment/python环境安装.html":{"url":"Linux/Environment/python环境安装.html","title":"Python环境安装","keywords":"","body":" 手动安装 下载安装 虚拟环境 pip使用 自动安装脚本 手动安装 下载安装 下载centos依赖包 yum install gcc wget gdb -y yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel yum install libffi-devel -y 下载并安装python # 下载需要的python版本，并解压 wget [https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz](http://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz) tar -xzvf Python-3.6.3.tar.gz cd Python-3.6.3 # 创建并指定安装路径 mkdir -p /opt/python3.6 ./configure --prefix=/opt/python3.6 #(./configure --enable-shared --prefix=/opt/python3.6 加上--enable-shared参数就可以生成对应动态链接库 pyinstaller 模块要用) make && make install # 创建系统命令软链接python和pip ln -s /opt/python3.6/bin/python3.6 /usr/bin/python3 ln -s /opt/python3.6/bin/pip3.6 /usr/bin/pip 虚拟环境 虚拟环境virtualenv及管理工具virtualenvwrapper pip install --upgrade pip # 更新pip pip install virtualenv # 安装虚拟环境 find / -name virtualenv # 查找virtualenv安装路径（/opt/python3.6/bin/virtualenv） ln -s /opt/python3.6/bin/virtualenv /usr/bin/virtualenv #创建virtualenv软链接 virtualenv -p /opt/python3.6/bin/python3.6 venv #创建venv虚拟环境，-p参数指定Python解释器程序路径，可不用 source /centos/lxj/virtualenv/venv/bin/activate #激活虚拟环境 deactivate # 退出虚拟环境 #编辑虚拟环境快速启动别名 vi ~/.bashrc alias venv='source /home/lxj/env/venv/bin/activate && cd /home/lxj/' source ~/.bashrc # 执行生效 virtualenvwrapper 虚拟环境管理工具 virtualenv --relocatable 创建虚拟沙盒，代替环境安装 打包虚拟环境 [lxj@centos ~]$ /opt/python3.6/bin/virtualenv --relocatable venv/ 移植到新的主机上后修改环境变量 VIRTUAL_ENV **virtualenvwrapper** 虚拟环境集中管理 yum install python-setuptools python-devel pip install virtualenvwrapper # 安装 pip install virtualenvwrapper-win Windows安装 配置环境变量，在~/.bashrc写入以下内容 export WORKON_HOME=~/Envs # virtualenvwrapper存放虚拟环境目录 source /usr/local/bin/virtualenvwrapper.sh　 # 会安装到python的bin目录下，路径是python安装目录下bin/virtualenvwrapper.sh source ~/.bashrc　#读入配置文件，立即生效 基本命令 **mkvirtualenv** **--python**=/usr/local/python3.5.3/bin/python venv #创建虚拟环境，指定python版本解释器 **workon** # 查看当前的虚拟环境目录 **workon venv** # 切换到虚拟环境 deactivate # 退出虚拟环境 rmvirtualenv venv # 删除虚拟环境 (venv) [lxj@centos ~]$ pip install -i [https://pypi.douban.com/simple/](http://pypi.douban.com/simple/) --trusted-host=[pypi.douban.com/simple/](http://pypi.douban.com/simple/) -r requirements.txt mkdir -p /opt/python36/ chmod -R a+x /opt/python36/ chown -R lxj /opt/python36 pip使用 导出批量安装 pip freeze > requirements.txt # 将已安装的模块导出 pip install -r requirements.txt # 批量安装 使用源安装 pip install -i http://pypi.douban.com/simple/ --trusted-host=pypi.douban.com/simple django 永久修改pip源 pip使用帮助 写在配置文件里 vi ~/.pip/pip.conf (没有就创建) [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple # [install] # trusted-host = pypi.douban.com # 用https需要添加这行 pip国内源 豆瓣(douban) http://pypi.douban.com/simple/ 阿里云 https://mirrors.aliyun.com/pypi/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ setup.py 安装模块 # 安装setuptools # 下载setuptools源码包: https://pypi.python.org/pypi/setuptools setup_url = 'https://files.pythonhosted.org/packages/68/75/d1d7b7340b9eb6e0388bf95729e63c410b381eb71fe8875cdfd949d8f9ce/setuptools-45.2.0.zip' # 解压后进入目录 python setup.py install # 安装pip # pip源码包: https://pypi.python.org/pypi/pip#downloads python setup.py build (可以不用build，直接install) python setup.py install 自动安装脚本 # -*- coding: utf-8 -*- # centos下用python2自动安装开发环境脚本 import os class RunTool(object): '''安装工具/包/网址''' def __init__(self): pass def run_cmd(self, cmd): result = os.system(cmd) if not result == 0: return False # TODO 此处报错处理应用raise处理 return True def download_packets(self, url): # TODO 需判断URL为正确链接格式 # TODO 此处下载需要进行重试及下载完成验证 download_filename = url.split('/')[-1] if not self.check_exist_path(download_filename): download_cmd = 'wget %s' % (url) if self.run_cmd(download_cmd): if not self.check_exist_path(download_filename): return False return download_filename return download_filename def check_exist_path(self, path): return os.path.exists(path) def switch_path(self, path): '''切换工作路径''' return os.chdir(path) def yum_install(self, packet): return self.run_cmd('yum install -y %s' % (packet)) class LinuxInstall(RunTool): '''Linux环境及扩展安装''' def __init__(self): pass def check_install(self, base_packets): '''检查linux包是否安装''' has_been_install = [] for packet in base_packets: rpm_cmd = \"rpm -qa | egrep -i '%s'\" % (packet) rpm_results = os.popen(rpm_cmd).readlines() # 得到的结果列表 if rpm_results: for result in rpm_results: if packet in result: has_been_install.append(packet) has_install = list(set(has_been_install)) print('Have been install %s' % (has_install)) for install_packets in has_install: base_packets.remove(install_packets) return base_packets def replace_yum(self, yum_path, yum_url, old_yum): '''替换yum源''' # help doc: http://mirrors.163.com/.help/centos.html self.switch_path(yum_path) install_wget_name = self.check_install(['wget']) if len(install_wget_name) == 1: install_name = install_wget_name.pop() if self.yum_install(install_name): back_cmd = 'mv %s %s.back' % (old_yum, old_yum) if self.run_cmd(back_cmd): yum_file_name = self.download_packets(yum_url) if self.check_exist_path(yum_file_name): self.run_cmd('yum clean all') self.run_cmd('yum makecache') def install_linux_packets(self, base_packets): '''安装linux包''' install_packets = self.check_install(base_packets) if not install_packets: packets_str = ','.join(install_packets) print('%s packets has been install' % (packets_str)) return True for packet in install_packets: if self.run_cmd('yum install -y %s' % (packet)): if self.check_install([packet]): print('install %s packets failed' % (packet)) return False print('install %s packets success' % (packet)) return True class PythonInstall(RunTool): '''python3环境及虚拟环境安装''' def __init__(self, python_path): self.python_path = python_path self.virtualenv_install_path = self.python_path + '/bin/virtualenv' def install_python3(self, python3_down_url): # #TODO 除了下载链接，可以提供下载路径 if not self.check_exist_path(self.python_path): self.run_cmd('mkdir -p %s' % (self.python_path)) self.switch_path(self.python_path) down_filename = self.download_packets(python3_down_url) # 解压到指定路径 tar_python_cmd = 'tar -xzvf %s -C /%s' % ( down_filename, self.python_path) self.run_cmd(tar_python_cmd) tar_path = '.'.join(down_filename.split('.')[:-1]) self.switch_path('%s/%s' % (self.python_path, tar_path)) # 指定安装的python路径 install_python3_cmd = './configure --prefix=%s' % (self.python_path) self.run_cmd(install_python3_cmd) self.run_cmd('make && make install') # TODO判断软连接文件有问题 if self.check_exist_path('/usr/bin/python3'): self.run_cmd('rm -rf /usr/bin/python3') # 创建软链接 self.run_cmd('ln -s %s/bin/python3 /usr/bin/python3' % (self.python_path)) # 测试安装是否成功 if not self.run_cmd('python3 -V'): print('install python3 failed') return False print('install python3 success') return True def install_virtualenv(self, env_name, user): if self.run_cmd('%s/bin/pip3 install -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com virtualenv' % (self.python_path)): self.run_cmd('rm -rf /usr/bin/virtualenv') virtualenv_ln_cmd = 'ln -s %s /usr/bin/virtualenv' % ( self.virtualenv_install_path) if not self.run_cmd(virtualenv_ln_cmd): return 'install virtualenv failed' virtualenv_path = '/home/%s' % (user) if not self.check_exist_path(virtualenv_path): self.run_cmd('mkdir -p %s' % (virtualenv_path)) self.switch_path(virtualenv_path) chown_cmd = 'chown -R %s:%s %s' % (user, user, self.python_path) self.run_cmd(chown_cmd) virtualenv_cmd = 'virtualenv -p %s/bin/python3 %s' % ( self.python_path, env_name) if self.run_cmd(virtualenv_cmd): env_path = '%s/%s' % (virtualenv_path, env_name) chown_env_cmd = 'chown -R %s:%s %s' % (user, user, env_path) self.run_cmd(chown_env_cmd) # 激活虚拟环境 virtualenv_test_cmd = 'source %s/%s/bin/activate' % ( virtualenv_path, env_name) if self.run_cmd(virtualenv_test_cmd): print('install virtualenv success') return 'install virtualenv success' class ConfigArgs(object): BASE_PACKETS = ['gcc', 'wget', 'gdb', 'vim','net-tools'] PYTHON_RELY = ['zlib-devel', 'bzip2-devel', 'openssl-devel', 'ncurses-devel', 'sqlite-devel', 'readline-devel', 'tk-devel', 'gdbm-devel', 'db4-devel', 'libpcap-devel', 'xz-devel', 'libffi-devel'] YUM_PATH = '/etc/yum.repos.d' YUM_URL = 'http://mirrors.163.com/.help/CentOS7-Base-163.repo' OLD_YUM = 'CentOS-Base.repo' PYTHON_URL = 'https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz' PIP_URL = 'https://files.pythonhosted.org/packages/8e/76/66066b7bc71817238924c7e4b448abdb17eb0c92d645769c223f9ace478f/pip-20.0.2.tar.gz' PYTHON_PATH = '/tmp/python3' ENV_NAME = 'env' NORMAL_USER = 'cen' def main(): python_install = PythonInstall(ConfigArgs.PYTHON_PATH) linux_install = LinuxInstall() linux_install.replace_yum( ConfigArgs.YUM_PATH, ConfigArgs.YUM_URL, ConfigArgs.OLD_YUM) linux_base = linux_install.install_linux_packets( ConfigArgs.BASE_PACKETS+ConfigArgs.PYTHON_RELY) if linux_base: # # import pdb # # pdb.set_trace() result = python_install.install_python3(ConfigArgs.PYTHON_URL) if result: python_install.install_virtualenv( ConfigArgs.ENV_NAME, ConfigArgs.NORMAL_USER) result = python_install.install_python3(ConfigArgs.PYTHON_URL) if result: python_install.install_virtualenv( ConfigArgs.ENV_NAME, ConfigArgs.NORMAL_USER) if __name__ == \"__main__\": main() var className='atoc';"},"Linux/Others/Untitled.html":{"url":"Linux/Others/Untitled.html","title":"Untitled","keywords":"","body":"博客： https://www.cnblogs.com/Raodi/category/1466354.html var className='atoc';"},"Linux/Others/markdown语法.html":{"url":"Linux/Others/markdown语法.html","title":"Markdown语法","keywords":"","body":"# 锚定跳转(typora 跳转 cltrl + 鼠标左键) [点击这里跳转](#1) 跳转到这 标题1 [回到标题1](#标题1) var className='atoc';"},"Linux/Others/vimium快捷键.html":{"url":"Linux/Others/vimium快捷键.html","title":"Vimium快捷键","keywords":"","body":"vim操作chrom插件 - vimium 常用快捷键操作 参数 功能 ? 显示帮助 f/F 打开链接定位器，输入编号在 当前/新 标签页打开 o/O 搜索引擎(需配置)或检索书签历史记录等b: https://www.bing.com/search?q=%s Bingzh: https://www.zhihu.com/search?type=content&q=%s 知乎bky: https://zzk.cnblogs.com/s/blogpost?w=%s 博客园bz https://search.bilibili.com/all?keyword=%s b站 b/B 只检索书签栏，然后在 当前/新的 标签中打开 浏览页面 ------------------------------ j/k 向 下(或d)/上(或u)滚动(或d) gg/G 滚动到页面最 顶/底 部 r 重新载入页面（刷新） zH/zL 页面左右滚动 标签操作 ------------------------------ t/T 新建标签/搜索所有打开的便签并切换 x/X 关闭当前的/恢复关闭的 标签页 J/k 跳转到 左侧(或gT)/右侧(或gt) 标签页 ^ 返回到上个访问的标签 shift+6 g0/g$ 跳转第一个/最后一个标签 > 向 左/右 移动标签页 浏览历史 ------------------------------ H/L 查看 前/后 一条历史记录(回到 前/后 一页) / 页面查找模式(n/N 循环向 前/后 查找匹配项) yy 将当前网址复制到剪贴板 p/P 在 当前/新的 标签页中打开剪贴板的URL gf/gF 聚焦下一帧(特别看视频时有用) **预览模式（visual mode） v 进入预览模式** 先用 / 定位，找到想要选择的字符 再按 v ,进入模式 然后使用 j：向下一行 k：向上一行 h：向左一个字符或标点（数字+h，可以移动多个字符） l：向右一个字符或标点（数字+l，可以移动多个字符） w：下一个标点符号后位置，包括看不见的换行符 e：下一个标点符号前位置 b：取消选中上一个字符，字符和标点算一个字符 y：可以复制选中的字符串 var className='atoc';"},"Linux/Services/Apache web服务器.html":{"url":"Linux/Services/Apache web服务器.html","title":"Apache Web服务器","keywords":"","body":"[toc] 安装Http yum install httpd # 安装apache systemctl start httpd # 启动 systemctl enable httpd # 加入开机启动 配置文件 服务目录 /etc/httpd 主配置文件 /etc/httpd/conf/httpd.conf 网站数据目录 /var/www/html 访问日志 /var/log/httpd/access_log 错误日志 /var/log/httpd/error_log vim /etc/httpd/conf/httpd.conf 配置httpd服务程序时最常用的参数以及用途描述 ServerRoot 服务目录 ServerAdmin 管理员邮箱 User 运行服务的用户 Group 运行服务的用户组 ServerName 网站服务器的域名 DocumentRoot 网站数据目录 Listen 监听的IP地址与端口号 DirectoryIndex 默认的索引页页面 ErrorLog 错误日志文件 CustomLog 访问日志文件 Timeout 网页超时时间，默认为300秒 DocumentRoot 查看网站数据目录,修改index页面 echo \"Welcome To LinuxProbe.Com\" > /var/www/html/index.html 个人用户主页功能 修改配置vim /etc/httpd/conf.d/userdir.conf 注释17行 UserDir disabled功能,打开24行 UserDir public_html UserDir参数表示网站数据在用户家目录中的保存目录名称，即public_html目录 11 12 # 13 # UserDir is disabled by default since it can confirm the presence 14 # of a username on the system (depending on home directory 15 # permissions). 16 # 17 # UserDir disabled 18 19 # 20 # To enable requests to /~user/ to serve the user's public_html 21 # directory, remove the \"UserDir disabled\" line above, and uncomment 22 # the following line instead: 23 # 24 UserDir public_html 25 修改个人用户主页 ➜ [/home/lxj] su - lxj ➜ [/home/lxj] mkdir public_html ➜ [/home/lxj] echo \"This is lxj websit\" > public_html/index.html ➜ [/home/lxj] chmod 755 /home/lxj 网页浏览个人主页: http://192.168.44.128/~lxj/ getsebool命令查询并过滤出所有与HTTP协议相关的安全策略 用setsebool命令来修改SELinux策略中各条规则的布尔值,在setsebool命令后面加上-P参数，让修改后的SELinux策略规则永久生效且立即生效 setsebool -P httpd_enable_homedirs=on [ ] TODO https://www.linuxprobe.com/chapter-10.html#105 rpm -qa httpd #查看是否安装有httpd yum install httpd* -y #安装httpd systemctl start httpd.service systemctl status httpd.service systemctl stop httpd.service 配置 服务目录 /etc/httpd 主配置文件 /etc/httpd/conf/httpd.conf 网站数据目录 /var/www/html 访问日志 /var/log/httpd/access_log 错误日志 /var/log/httpd/error_log 配置参数 ServerRoot 服务目录 ServerAdmin 管理员邮箱 User 运行服务的用户 Group 运行服务的用户组 ServerName 网站服务器的域名 DocumentRoot 网站数据目录 Listen 监听的IP地址与端口号 DirectoryIndex 默认的索引页页面 ErrorLog 错误日志文件 CustomLog 访问日志文件 Timeout 网页超时时间,默认为300秒. Include 需要加载的其他文件 httpd -t #修改完后，使用httpd -t检查语法是否有误 var className='atoc';"},"Linux/Services/Crontab 定时任务.html":{"url":"Linux/Services/Crontab 定时任务.html","title":"Crontab 定时任务","keywords":"","body":" 定时任务-crontab crontab命令 crontab设置 二.一次性任务-st 定时任务-crontab crontab命令 参数 作用 -e 编辑该用户的计时器设置 -l 列出该用户的计时器设置 -r 删除该用户的计时器设置 -u 指定要设定计时器的用户名称 crontab -l #查看当前计划任务 crontab -e #创建、编辑计划任务 crontab -r #删除某条计划任务 crontab -e -u lxj # 编辑lxj用户的定时任务 minute hour day month week command 顺序：分 时 日 月 周 命令 minute分钟：0-59 之间的任何整数 hour小时：1-23day日期：1-31mouth月份：1-12week星期：0-6（0/7表示周日）command：要执行的命令,系统命令或脚本文件 可以用符号表示* 表示任何时刻, 指定列表范围，\"1,3,5,7\"- 指定整数范围，\"1-5\" 表示 \"1,2,3,4,5\" 1到5点/n 表示执行频率，每个n的单位执行一次，如：*/1, 就表示每隔1个小时执行一次命令。也可以写成1-23/1 注意： 在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写 计划任务中的“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字段不能同时使用，否则就会发生冲突。 定时任务设置举例 说明 43 21 * 21:43 执行 43 21 * 21:43 执行 15 05 * 05:15 执行 0 17 * 17:00 执行 0 17 1 每周一的17:00 执行 0,10 17 0,2,3 每周日,周二,周三的17:00和17:10 执行 0-10 17 1 毎月1日从17:00到7:10毎隔1分钟 执行 0 0 1,15 * 1 毎月1日和15日和一日的0:00 执行 42 4 1 毎月1日的4:42分 执行 0 21 1-6 周一到周六21:00 执行 0,10,20,30,40,50 每隔10分 执行 /10 * 每隔10分 执行 1 从1:0到1:59每隔1分钟 执行 0 1 * 1:00 执行 0 /1 毎时0分每隔1小时 执行 0 毎时0分 执行 2 8-20/3 * 8:02,11:02,14:02,17:02,20:02 执行 30 5 1,15 1日和15日的5:30 执行 rm -rf /mnt/ 每分钟删除一次 /2 rm -rf /mnt/ 每隔2分钟删除一次 /2 rm -rf /mnt/ 每隔2小时删除一次 10-12 rm -rf /mnt/* 每天十点到十二点每分钟删除一次 10,20 rm -rf /mnt/* 每个月的十号二十号每分钟删除一次 10-20 rm -rf /mnt/* 每个月的十号至二十号每分钟删除一次 6 rm -rf /mnt/* 六月份每分钟删除一次 2,5 rm -rf /mnt/* 每周二周五每分钟删除一次 2-5 rm -rf /mnt/* 每周二到周五每分钟删除一次 crontab设置 service crond status 检查crond服务是否运行 /sbin/service 或 ps -elf|grep crond|grep -v \"grep\" /sbin/service crond status pgrep crond service crond start 手动启动crontab服务 service crond stop 关闭crontab服务 service crond restart 重启服务 service crond reload 重新载入配置 ntsysv 查看crontab服务是否已设置为开机启动 (设置系统的各种服务) chkconfig –level 35 crond on 加入开机自动启动 安装cron yum install vixie-cron yun install crontabs 自动添加crontab 任务 1.编辑 /var/spool/cron/用户名文件 echo \"* * * * * hostname >> /tmp/tmp.txt\" >> /var/spool/cron/root 2.编辑 /etc/crontab 文件, 需指定用户名,文件定义为系统级定时任务 不建议添加非系统类定时任务，编辑该文件也需要root权限 echo \"* * * * * root hostname >> /tmp/tmp.txt\" >> /etc/crontab 3. 利用crontab -l 加 crontab file 两个命令实现自动添加，由于crontab file会覆盖原有定时任务，所以使用 crontab -l 先导出原有任务到临时文件 “conf” 再追加新定时任务 crontab -l > conf && echo \"* * * * * hostname >> /tmp/tmp.txt\" >> conf && crontab conf && rm -f conf 发起方式二#vim /etc/cron.d/filename[root@centos ~]# cat >> file /dev/null 2>&1 “/dev/null 2>&1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。 3. 系统级任务调度与用户级任务调度 系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。 4. 其他注意事项 新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。 当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。 千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。 在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\\%Y\\%m\\%d’。 查看cron服务是否起作用： 查看定时任务是否准时调用了可以/var/log/cron中的运行信息 cat /var/log/cron 或 grep .*\\.sh /var/log/cron 搜索.sh类型文件信息 crontab不执行，可进行如下操作： crontab -u root /var/spool/cron/root 或 service crond restart 重启服务 二.一次性任务-st at命令 一次性计划任务只执行一次，一般用于满足临时的工作需求。可以用at命令实现这种功能，只需要写成“at 时间”的形式就可以。 at -l 查看已设置好但未执行的一次性任务 atrm 任务序号 可将对应序号任务删除 使用at命令来设置一次性计划任务时，默认采用的是交互式方法 [root@linuxprobe ~]# at 23:30 at > systemctl restart httpd at > 此处请同时按下Ctrl+d来结束编写计划任务 job 3 at Mon Apr 27 23:30:00 2015 [root@linuxprobe ~]# echo \"systemctl restart httpd\" | at 23:30 也可这种非交互式写法创建at任务 [root@linuxprobe ~]# at -l 3 Mon Apr 27 23:30:00 2016 a root at now+1min #延迟一分钟 at -f file #延迟执行文件中的内容 var className='atoc';"},"Linux/Services/DNS 域名解析服务.html":{"url":"Linux/Services/DNS 域名解析服务.html","title":"DNS 域名解析服务","keywords":"","body":" DNS域名解析服务 DNS简介 DNS域名解析服务 DNS简介 域名和ip地址之间的解析转换 正向解析： 域名 --> IP地址 (常用) 方向解析： IP地址 --> 域名 域名组成与分类 |域名组成|分类| |-|-| |.|根域，可省略不写 | |com|顶级域，由ICANN组织指定和管理 分类：国家地区顶级域名：cn(中国）、hk(香港）、sg(新加坡）等 通用项级域名：com(商业机构）、org(非营利组织）、edu(教育机构）gov（政府部门）、net（网络服务商）、pub（公共大众）等。新通用顶级域名：red(红色、热情）、top(顶级、高端）等| |baidu,google |二级域（注册域）,可由个人或组织申请注册。| |www |三级域（子域）,服务器网站名代表。| |主机名|sl.www.baidu.com.中的s1 就是主机名，一般用来表示具体某一台主机| DNS域名解析步骤 客户机首先查看查找本地hosts文件，如果有则返回，否则进行下一步。 客户机查看本地缓存，是否存在本条目的缓存，如果有则直接返回，否则进行下一步。 将请求转发给指向的DNS服务器。 查看域名是否本地解析，是则本地解析返回，否则进行下一步。 本地DNS服务器首先在缓存中查找，有则返回，无则进行下一步。（根域，顶级域，二级域） 向全球13个根域服务器发起DNS请求，根域返回org域的地址列表。 使用某一个org域的IP地址，发起DNS请求，ong域返回kemel域服务器地址列表。 使用某一个kemel域IP地址，发起DNS请求，kemel域返回www.kemelorg主机的IP地址，本 地DNS服务收到后，返回给客户机，并在本地DNS服务器保存一份。 DNS服务 软件名称： bind 服务名称： named 软件端口：UDP 53 数据通信（域名解析） TCP 53 数据同步（主从同步） 配置文件： 1. 主配置文件 /etc/named.conf(服务器运行参数) 2. 区域配置文件 /etc/named.rfc1912.zones(服务器解析的区域配置，正反向区域定义信息) 3. 数据配置文件 /var/named/xxx.xxx 4. 其他目录及文件： /var/named/named.ca #保存了13台根服务器的位置 /var/named/slaves #从服务器的配置信息等 var className='atoc';"},"Linux/Services/FTP 文件传输服务器.html":{"url":"Linux/Services/FTP 文件传输服务器.html","title":"FTP 文件传输服务器","keywords":"","body":" 匿名开放模式 本地用户模式 虚拟用户模式 FTP 是文件传输协议,基于客户端/服务器模式，默认使用20、21号端口，其中端口20（数据端口）用于进行数据传输，端口21（命令端口）用于接受客户端发出的相关FTP命令与参数,vsftpd是最主流的FTP服务器程序. 空iptables防火墙的默认策略，并把当前已经被清理的防火墙策略状态保存下来 [root@linuxprobe ~]# iptables -F [root@linuxprobe ~]# service iptables save iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ] vsftpd服务程序的主配置文件（/etc/vsftpd/vsftpd.conf） 可以在grep命令后面添加-v参数，过滤并反选出没有包含井号（#）的参数行（即过滤掉所有的注释信息），然后将过滤后的参数行通过输出重定向符写回原始的主配置文件中 [root@linuxprobe ~]# mv /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf_bak [root@linuxprobe ~]# grep -v \"#\" /etc/vsftpd/vsftpd.conf_bak > /etc/vsftpd/vsftpd.conf [root@linuxprobe ~]# cat /etc/vsftpd/vsftpd.conf vsftpd服务程序常用的参数以及作用 参数 作用 listen=[YES\\ NO] 是否以独立运行的方式监听服务 listen_address=IP地址 设置要监听的IP地址 listen_port=21 设置FTP服务的监听端口 download_enable＝[YES\\ NO] 是否允许下载文件 userlist_enable=[YES\\ NO] userlist_deny=[YES\\ NO] 设置用户列表为“允许”还是“禁止”操作 max_clients=0 最大客户端连接数，0为不限制 max_per_ip=0 同一IP地址的最大连接数，0为不限制 anonymous_enable=[YES\\ NO] 是否允许匿名用户访问 anon_upload_enable=[YES\\ NO] 是否允许匿名用户上传文件 anon_umask=022 匿名用户上传文件的umask值 anon_root=/var/ftp 匿名用户的FTP根目录 anon_mkdir_write_enable=[YES\\ NO] 是否允许匿名用户创建目录 anon_other_write_enable=[YES\\ NO] 是否开放匿名用户的其他写入权限（包括重命名、删除等操作权限） anon_max_rate=0 匿名用户的最大传输速率（字节/秒），0为不限制 local_enable=[YES\\ NO] 是否允许本地用户登录FTP local_umask=022 本地用户上传文件的umask值 local_root=/var/ftp 本地用户的FTP根目录 chroot_local_user=[YES\\ NO] 是否将用户权限禁锢在FTP目录，以确保安全 local_max_rate=0 本地用户最大传输速率（字节/秒），0为不限制 匿名开放模式 是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器 不建议在生产环境中放开以下这些权限 可以向匿名用户开放的权限参数以及作用 参数 作用 anonymous_enable=YES 允许匿名访问模式 anon_umask=022 匿名用户上传文件的umask值 anon_upload_enable=YES 允许匿名用户上传文件 anon_mkdir_write_enable=YES 允许匿名用户创建目录 anon_other_write_enable=YES 允许匿名用户修改目录名称或删除目录 vim /etc/vsftpd/vsftpd.conf [root@centos1 ~]# vim /etc/vsftpd/vsftpd.conf anonymous_enable=YES anon_umask=022 anon_upload_enable=YES anon_mkdir_write_enable=YES anon_other_write_enable=YES local_enable=YES ... [ ] TODO [ ] https://www.linuxprobe.com/chapter-11.html 本地用户模式 通过Linux系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。 虚拟用户模式 这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。 var className='atoc';"},"Linux/Services/Firewalld 防火墙.html":{"url":"Linux/Services/Firewalld 防火墙.html","title":"Firewalld 防火墙","keywords":"","body":" Firewalld 防火墙 Firewalld 常用命令 配置 firewall-cmd 工具 Iptables SELinux 安全子系统 Centos7开放及查看端口 iptables和firewalld的介绍与区别 https://blog.csdn.net/Bilise/article/details/105372667 https://www.jianshu.com/p/cbf8e0009bc0 https://www.linuxprobe.com/chapter-10.html 10.3 https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-using_firewalls#sec-Comparison_of_Firewalld_to_system-config-firewall_and_iptables Firewalld 防火墙 防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制 iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理 firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理 firewalld的配置方法主要有三种：firewall-config、firewall-cmd和直接编辑xml文件，其中 firewall-config是图形化工具，firewall-cmd是命令行工具 查看端口被哪个进程占用 netstat -tunlp|grep 8080 Firewalld 常用命令 yum install firewalld firewall-config # 安装 systemctl start firewalld # 开启防火墙 systemctl restart firewalld systemctl stop firewalld # 关闭 systemctl status firewalld 或者 firewall-cmd --state # 查看防火墙状态 systemctl enable firewalld.service #开机启用服务 systemctl disable firewalld.service #开机禁用服务 systemctl is-enabled firewalld.service #查看服务是否开机启动 systemctl --failed #查看启动失败的服务列表 systemctl list-unit-files|grep enabled #查看已启动的服务列表 systemctl list-unit-files | grep firewalld.service # 查看是否开机启动 systemctl mask firewalld #执行命令，即可实现取消服务的锁定 systemctl unmask firewalld # 下次需要锁定该服务时执行 配置 系统配置目录/usr/lib/firewalld/services 目录中存放定义好的网络服务和端口参数，系统参数，不能修改 用户配置目录/etc/firewalld/ firewall-cmd 工具 firewall-cmd --state #查看防火墙状态 firewall-cmd --reload #更新防火墙规则 firewall-cmd --state #查看防火墙状态 firewall-cmd --reload #重载防火墙规则 firewall-cmd --list-ports #查看所有打开的端口 firewall-cmd --list-services #查看所有允许的服务 firewall-cmd --get-services #获取所有支持的服务 #区域相关 firewall-cmd --list-all-zones #查看所有区域信息 firewall-cmd --get-active-zones #查看活动区域信息 firewall-cmd --set-default-zone=public #设置public为默认区域 firewall-cmd --get-default-zone #查看默认区域信息 firewall-cmd --zone=public --add-interface=eth0 #将接口eth0加入区域public #接口相关 firewall-cmd --zone=public --remove-interface=eth0 #从区域public中删除接口eth0 firewall-cmd --zone=default --change-interface=eth0 #修改接口eth0所属区域为default firewall-cmd --get-zone-of-interface=eth0 #查看接口eth0所属区域 #端口控制 firewall-cmd --add-port=80/tcp --permanent #永久添加80端口例外(全局) firewall-cmd --remove-port=80/tcp --permanent #永久删除80端口例外(全局) firewall-cmd --add-port=65001-65010/tcp --permanent #永久增加65001-65010例外(全局) firewall-cmd --zone=public --add-port=80/tcp --permanent #永久添加80端口例外(区域public) firewall-cmd --zone=public --remove-port=80/tcp --permanent #永久删除80端口例外(区域public) firewall-cmd --zone=public --add-port=65001-65010/tcp --permanent #永久增加65001-65010例外(区域public) firewall-cmd --query-port=8080/tcp # 查询端口是否开放 firewall-cmd --permanent --add-port=80/tcp # 开放80端口 firewall-cmd --permanent --remove-port=8080/tcp # 移除端口 firewall-cmd --reload #重启防火墙(修改配置后要重启防火墙) 显示状态：$ firewall-cmd --state 查看区域信息: $ firewall-cmd --get-active-zones 查看指定接口所属区域：$ firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：# firewall-cmd --panic-on 取消拒绝状态：# firewall-cmd --panic-off 查看是否拒绝：$ firewall-cmd --query-panic 更新防火墙规则：# firewall-cmd --reload # firewall-cmd --complete-reload 两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务 将接口添加到区域，默认接口都在public # firewall-cmd --zone=public --add-interface=eth0 永久生效再加上 --permanent 然后reload防火墙 设置默认接口区域 # firewall-cmd --set-default-zone=public 立即生效无需重启 打开端口（貌似这个才最常用） 查看所有打开的端口： # firewall-cmd --zone=dmz --list-ports 加入一个端口到区域： # firewall-cmd --zone=dmz --add-port=8080/tcp 若要永久生效方法同上 打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档 # firewall-cmd --zone=work --add-service=smtp 移除服务 # firewall-cmd --zone=work --remove-service=smtp Iptables yum install iptables-services #安装iptables systemctl stop firewalld.service #停止firewalld systemctl mask firewalld.service #禁止自动和手动启动firewalld systemctl start iptables.service #启动iptables systemctl start ip6tables.service #启动ip6tables systemctl enable iptables.service #设置iptables自启动 systemctl enable ip6tables.service #设置ip6tables自启动 iptables 基本命令使用举例 一、链及NAT的基本操作 1、清除所有的规则。 1）清除预设表filter中所有规则链中的规则。 # iptables -F 2）清除预设表filter中使用者自定链中的规则。 #iptables -X #iptables -Z 3)清楚NAT表规则 #iptables -F -t nat 4)NAT表的显示 #iptables -t nat -nL 2、设置链的默认策略。一般有两种方法。 1）首先允许所有的包，然后再禁止有危险的包通过放火墙。 #iptables -P INPUT ACCEPT #iptables -P OUTPUT ACCEPT #iptables -P FORWARD ACCEPT 2）首先禁止所有的包，然后根据需要的服务允许特定的包通过防火墙。 #iptables -P INPUT DROP #iptables -P OUTPUT DROP #iptables -P FORWARD DROP 3、列出表/链中的所有规则。默认只列出filter表。 #iptables -L 4、向链中添加规则。下面的语句用于开放网络接口： #iptables -A INPUT -i lo -j ACCEPT #iptables -A OUTPUT -o lo -j ACCEPT #iptables -A INPUT -i eth0 -j ACEPT #iptables -A OUTPUT -o eth1 -j ACCEPT #iptables -A FORWARD -i eth1 -j ACCEPT #iptables -A FORWARD -0 eth1 -j ACCEPT 注意:由于本地进程不会经过FORWARD链，因此回环接口lo只在INPUT和OUTPUT两个链上作用。 5、使用者自定义链。 #iptables -N custom #iptables -A custom -s 0/0 -d 0/0 -p icmp -j DROP #iptables -A INPUT -s 0/0 -d 0/0 -j DROP 二、设置基本的规则匹配 1、指定协议匹配。 1）匹配指定协议。 #iptables -A INPUT -p tcp 2）匹配指定协议之外的所有协议。 #iptables -A INPUT -p !tcp 2、指定地址匹配。 1）指定匹配的主机。 #iptables -A INPUT -s 192.168.0.18 2）指定匹配的网络。 #iptables -A INPUT -s 192.168.2.0/24 3）匹配指定主机之外的地址。 #iptables -A FORWARD -s !192.168.0.19 4）匹配指定网络之外的网络。 #iptables -A FORWARD -s ! 192.168.3.0/24 3、指定网络接口匹配。 1）指定单一的网络接口匹配。 #iptables -A INPUT -i eth0 #iptables -A FORWARD -o eth0 2）指定同类型的网络接口匹配。 #iptables -A FORWARD -o ppp+ 4、指定端口匹配。 1）指定单一端口匹配。 #iptables -A INPUT -p tcp --sport www #iptables -A INPUT -p udp –dport 53 2）匹配指定端口之外的端口。 #iptables -A INPUT -p tcp –dport !22 3）匹配端口范围。 #iptables -A INPUT -p tcp –sport 22:80 4）匹配ICMP端口和ICMP类型。 #iptables -A INOUT -p icmp –icimp-type 8 5）指定ip碎片。 每 个网络接口都有一个MTU（最大传输单元），这个参数定义了可以通过的数据包的最大尺寸。如果一个数据包大于这个参数值时，系统会将其划分成更小的数据包 （称为ip碎片）来传输，而接受方则对这些ip碎片再进行重组以还原整个包。这样会导致一个问题：当系统将大数据包划分成ip碎片传输时，第一个碎片含有 完整的包头信息（IP+TCP、UDP和ICMP），但是后续的碎片只有包头的部分信息（如源地址、目的地址）。因此，检查后面的ip碎片的头部（象有 TCP、UDP和ICMP一样）是不可能的。假如有这样的一条规则： #iptables -A FORWARD -p tcp -s 192.168.1.0/24 -d 192.168.2.100 –dport 80 -j ACCEPT 并且这时的FORWARD的policy为DROP时，系统只会让第一个ip碎片通过，而余下的碎片因为包头信息不完整而无法通过。可以通过—fragment/-f 选项来指定第二个及以后的ip碎片解决上述问题。 #iptables -A FORWARD -f -s 192.168.1.0/24 -d 192.168.2.100 -j ACCEPT 注意现在有许多进行ip碎片攻击的实例，如DoS攻击，因此允许ip碎片通过是有安全隐患的，对于这一点可以采用iptables的匹配扩展来进行限制。 三、设置扩展的规则匹配（举例已忽略目标动作） 1、多端口匹配。 1）匹配多个源端口。 #iptables -A INPUT -p tcp -m multiport –sport 22,53,80,110 2）匹配多个目的端口。 #iptables -A INPUT -p tcp -m multiport –dpoort 22,53,80 3）匹配多端口(无论是源端口还是目的端口） #iptables -A INPUT -p tcp -m multiport –port 22,53,80,110 2、指定TCP匹配扩展 使用 –tcp-flags 选项可以根据tcp包的标志位进行过滤。 #iptables -A INPUT -p tcp –tcp-flags SYN,FIN,ACK SYN #iptables -A FROWARD -p tcp –tcp-flags ALL SYN,ACK 上实例中第一个表示SYN、ACK、FIN的标志都检查，但是只有SYN匹配。第二个表示ALL（SYN，ACK，FIN，RST，URG，PSH）的标志都检查，但是只有设置了SYN和ACK的匹配。 #iptables -A FORWARD -p tcp --syn 选项—syn相当于”--tcp-flags SYN,RST,ACK SYN”的简写。 3、limit速率匹配扩展。 1）指定单位时间内允许通过的数据包个数，单位时间可以是/second、/minute、/hour、/day或使用第一个子母。 #iptables -A INPUT -m limit --limit 300/hour 2 )指定触发事件的阀值。 #iptables -A INPUT -m limit –limit-burst 10 用来比对一次同时涌入的封包是否超过10个，超过此上限的包将直接丢弃。 3）同时指定速率限制和触发阀值。 #iptables -A INPUT -p icmp -m limit –-limit 3/m –limit-burst 3 表示每分钟允许的最大包数量为限制速率（本例为3）加上当前的触发阀值burst数。任何情况下，都可保证3个数据包通过，触发阀值burst相当于允许额外的包数量。 4）基于状态的匹配扩展（连接跟踪） 每个网络连接包括以下信息：源地址、目标地址、源端口、目的端口，称为套接字对（socket pairs）；协议类型、连接状态（TCP协议） 和超时时间等。防火墙把这些信息称为状态（stateful）。状态包过滤防火墙能在内存中维护一个跟踪状态的表，比简单包过滤防火墙具有更大的安全性，命令格式如下： iptables -m state –-state [!]state [,state,state,state] 其中，state表是一个逗号分割的列表，用来指定连接状态，4种： >NEW: 该包想要开始一个新的连接（重新连接或连接重定向） >RELATED:该包是属于某个已经建立的连接所建立的新连接。举例： FTP的数据传输连接和控制连接之间就是RELATED关系。 >ESTABLISHED：该包属于某个已经建立的连接。 >INVALID:该包不匹配于任何连接，通常这些包被DROP。 例如： （1）在INPUT链添加一条规则，匹配已经建立的连接或由已经建立的连接所建立的新连接。即匹配所有的TCP回应包。 #iptables -A INPUT -m state –state RELATED,ESTABLISHED （2）在INPUT链链添加一条规则，匹配所有从非eth0接口来的连接请求包。 #iptables -A INPUT -m state -–state NEW -i !eth0 又如，对于ftp连接可以使用下面的连接跟踪： （1）被动（Passive）ftp连接模式。 #iptables -A INPUT -p tcp --sport 1024: --dport 1024: -m state –-state ESTABLISHED -j ACCEPT #iptables -A OUTPUT -p tcp --sport 1024: --dport 1024: -m state -–state ESTABLISHED,RELATED -j ACCEPT （2）主动（Active）ftp连接模式 #iptables -A INNPUT -p tcp --sport 20 -m state –-state ESTABLISHED,RELATED -j ACCEPT #iptables -A OUTPUT -p tcp –OUTPUT -p tcp –dport 20 -m state --state ESTABLISHED -j ACCEPT SELinux 安全子系统 关闭selinux [root@ipsan-node01 ~]# setenforce 0 setenforce: SELinux is disabled [root@ipsan-node01 ~]# getenforce Disabled [root@ipsan-node01 ~]# cat /etc/sysconfig/selinux ....... SELINUX=disabled Centos7开放及查看端口 1、开放端口 firewall-cmd --zone=public --add-port=5672/tcp --permanent # 开放5672端口 firewall-cmd --zone=public --remove-port=5672/tcp --permanent #关闭5672端口 firewall-cmd --reload # 配置立即生效 2、查看防火墙所有开放的端口 firewall-cmd --zone=public --list-ports 3.、关闭防火墙 如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估 systemctl stop firewalld.service 4、查看防火墙状态 firewall-cmd --state 5、查看监听的端口 netstat -lnpt PS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools 6、检查端口被哪个进程占用 netstat -lnpt |grep 5672 7、查看进程的详细信息 ps 6832 8、中止进程 kill -9 6832 var className='atoc';"},"Linux/Services/LNMP 架构网站搭建.html":{"url":"Linux/Services/LNMP 架构网站搭建.html","title":"LNMP 架构网站搭建","keywords":"","body":" 以下为书中命令 LNMP 自动安装脚本https://lnmp.org/download.html 见桌面 LNMP动态网站部署架构是一套由Linux + Nginx + MySQL + PHP组成的动态网站系统解决方案 需要安装如下依赖 [root@centos1 ~]# yum install -y apr* autoconf automake bison bzip2 bzip2* compat* cpp curl curl-devel fontconfig fontconfig-devel freetype freetype* freetype-devel gcc gcc-c++ gd gettext gettext-devel glibc kernel kernel-headers keyutils keyutils-libs-devel krb5-devel libcom_err-devel libpng libpng-devel libjpeg* libsepol-devel libselinux-devel libstdc++-devel libtool* libgomp libxml2 libxml2-devel libXpm* libtiff libtiff* make mpfr ncurses* ntp openssl openssl-devel patch pcre-devel perl php-common php-gd policycoreutils telnet t1lib t1lib* nasm nasm* wget zlib-devel 以下为书中命令 yum 安装，一条命令搞定 yum install httpd httd-devel mysql-server mysql-devel php pgp-devel php-mysql -y 源码安装 # Apache yum install apr-devel apr-util-devel -y cd /usr/src wget http://mirror.bit var className='atoc';"},"Linux/Services/MariaDB MySQL 服务.html":{"url":"Linux/Services/MariaDB MySQL 服务.html","title":"MariaDB MySQL 服务","keywords":"","body":" 初始化MariaDB服务 安装并启动 MariaDB 安装后正常使用前需初始化 管理用户及授权 查询用户信息 grant 命令用于为账户进行授权 数据库操作 创建数据库的命令以及作用 增删改查 CRUD 数据库备份及恢复 ISSUE 远程连接失败 Host 'xxx' is not allowed to connect to this MariaDB server 初始化MariaDB服务 安装并启动 yum install mariadb mariadb-server -y systemctl start mariadb systemctl enable mariadb MariaDB 安装后正常使用前需初始化 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。 设置root管理员在数据库中的专有密码。 随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。 删除默认的测试数据库，取消测试数据库的一系列访问权限。 刷新授权列表，让初始化的设定立即生效。 [root@centos1 ~]# mysql_secure_installation ... Enter current password for root (enter for none): #当前数据库密码为空，直接按回车键 Set root password? [Y/n] y Remove anonymous users? [Y/n] y（删除匿名账户） Disallow root login remotely? [Y/n] y（禁止root管理员从远程登录） Remove test database and access to it? [Y/n] y（删除test数据库并取消对它的访问权限） Reload privilege tables now? [Y/n] y（刷新授权表，让初始化后的设定立即生效） 在很多生产环境中都需要使用站库分离的技术（即网站和数据库不在同一个服务器上），如果需要让root管理员远程访问数据库，可在上面的初始化操作中设置策略，以允许root管理员从远程访问。然后还需要设置防火墙，使其放行对数据库服务程序的访问请求，数据库服务程序默认会占用3306端口，在防火墙策略中服务名称统一叫作mysql： [root@linuxprobe ~]# firewall-cmd --permanent --add-service=mysql success [root@linuxprobe ~]# firewall-cmd --reload success 设置密码 MariaDB [(none)]> SET password = PASSWORD('mysqlpasswd'); 管理用户及授权 CREATE USER 用户名@主机名 IDENTIFIED BY '密码'; 的格式创建数据库管理账户,结尾分号(;) MariaDB [(none)]> CREATE USER lxj@localhost IDENTIFIED BY 'lxjsqlpassws'; Query OK, 0 rows affected (0.00 sec) 查询用户信息 MariaDB [(none)]> use mysql MariaDB [mysql]> select host,user,password from user where user='lxj'; +-----------+------+-------------------------------------------+ | host | user | password | +-----------+------+-------------------------------------------+ | localhost | lxj | *355C3C0FADD71D72CABEF2412BC5ADA30A492CBC | +-----------+------+-------------------------------------------+ 1 row in set (0.00 sec) grant 命令用于为账户进行授权 在使用grant命令时需要写上要赋予的权限、数据库及表单名称，以及对应的账户及主机信息 GRANT命令的常见格式以及解释 命令 作用 GRANT 权限 ON 数据库.表单名称 TO 用户名@主机名 对某个特定数据库中的特定表单给予授权 GRANT 权限 ON 数据库.* TO 用户名@主机名 对某个特定数据库中的所有表单给予授权 GRANT 权限 ON . TO 用户名@主机名 对所有数据库及所有表单给予授权 GRANT 权限1,权限2 ON 数据库.* TO 用户名@主机名 对某个数据库中的所有表单给予多个授权 GRANT ALL PRIVILEGES ON . TO 用户名@主机名 对所有数据库及所有表单给予全部授权（需谨慎操作） MariaDB [mysql]> show grants for lxj@localhost; +----------------------------------------------------------------------------------------------------------+ | Grants for lxj@localhost | +---------------------------------------------------------------------------------------------------------- | GRANT USAGE ON *.* TO 'lxj'@'localhost' IDENTIFIED BY PASSWORD '*355C3C0FADD71D72CABEF2412BC5ADA30A492CBC' | GRANT SELECT, INSERT, UPDATE, DELETE ON `mysql`.`user` TO 'lxj'@'localhost' | +----------------------------------------------------------------------------------------------------------+ 2 rows in set (0.00 sec) 切回root账户，移除刚才的授权，移除授权的命令（revoke）与授权命令（grant）不同之外，其余部分都是一致的 MariaDB [mysql]> REVOKE SELECT,UPDATE,DELETE,INSERT ON mysql.user FROM lxj@localhost; Query OK, 0 rows affected (0.00 sec) 数据库操作 简单操作如下，深入了解见DataBases篇 创建数据库的命令以及作用 用法 作用 CREATE database 数据库名称。 创建新的数据库 DESCRIBE 表单名称; 描述表单 UPDATE 表单名称 SET attribute=新值 WHERE attribute > 原始值; 更新表单中的数据 USE 数据库名称; 指定使用的数据库 SHOW databases; 显示当前已有的数据库 SHOW tables; 显示当前数据库中的表单 SELECT * FROM 表单名称; 从表单中选中某个记录值 DELETE FROM 表单名 WHERE attribute=值; 从表单中删除某个记录值 增删改查 CRUD INSERT INTO mytable(rows,lines,name) VALUES('11','22', 'lxj'); DROP DATABASE mydata; DELETE FROM mytable; # 删除mytable表中的内容 UPDATE mytable SET rows=55 ; SELECT * FROM ... WHERE ...; where命令中使用的参数以及作用 参数 作用 = 相等 <>或!= 不相等 > 大于 小于 >= 大于或等于 小于或等于 BETWEEN 在某个范围内 LIKE 搜索一个例子 IN 在列中搜索多个值 数据库备份及恢复 mysqldump 命令用于备份数据库数据 mysqldump [参数] [数据库名称] 其中参数与mysql命令大致相同，-u参数用于定义登录数据库的账户名称，-p参数代表密码提示符。 将mydata数据库内容导出成一个文件，保存到root目录 [root@centos1 ~]# mysqldump -u root -p mydata > /root/mydata.dump 输入重定向符把刚刚备份的数据库文件导入到mysql中，就可以将恢复之前的数据了 [root@centos1 ~]# mysql -u root -p mydata ISSUE 远程连接失败 Host 'xxx' is not allowed to connect to this MariaDB server 方法一：改表 修改成%表示，所有主机都可以通过root用户访问数据库 MariaDB [mysql]> update user set host='%' where user='root'; MariaDB [mysql]> select host,user,password from user; +-----------------------+------+-------------------------------------------+ | host | user | password | +-----------------------+------+-------------------------------------------+ | % | root | *F2B1CE8FB96529C8598D17A00309E3B737CDB63E | +-----------------------+------+-------------------------------------------+ 5 rows in set (0.00 sec) 输入命令mysql> FLUSH PRIVILEGES; 使修改生效，再次远程连接数据库 方法二：授权 允许root使用mypassword从任何主机连接到mysql服务器的话。 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; 允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码 GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.1.3' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; 输入命令mysql> FLUSH PRIVILEGES; 使修改生效，再次远程连接数据库 FLUSH PRIVILEGES; 刷新先前的修改。 var className='atoc';"},"Linux/Services/Rsync 同步服务.html":{"url":"Linux/Services/Rsync 同步服务.html","title":"Rsync 同步服务","keywords":"","body":" Rsync简介 安装 功能介绍 Rsync的企业工作场景说明 远程数据同步方式（类似SCP） 守护进程方式同步数据 服务器 客户端 配置文件 rsync + inotify 实时同步 参考： https://clsn.io/clsn/lx920.html https://www.cnblogs.com/kevingrace/category/924886.html https://www.jianshu.com/p/d32414af2001 https://www.centos.bz/2018/11/centos7%e4%b8%8brsynccrontab%e5%ae%9a%e6%9c%9f%e5%90%8c%e6%ad%a5%e5%a4%87%e4%bb%bd/ Rsync简介 https://www.cnblogs.com/noxy/p/8986164.html rsync 具有如下的基本特性： 可以镜像保存整个目录树和文件系统 可以很容易做到保持原来文件的权限、时间、软硬链接等 无须特殊权限即可安装 优化的流程，文件传输效率高 可以使用 rsh、ssh 方式来传输文件，当然也可以通过直接的 socket 连接 支持匿名传输，以方便进行网站镜象 远程 Shell 方式（建议使用 ssh，用户验证由 ssh 负责）和 C/S 方式（即客户连接远程 rsync 服务器，用户验证由 rsync 服务器负责）。 无论本地同步目录还是远程同步数据，首次运行时将会把全部文件拷贝一次，以后再运行时将只拷贝有变化的文件（对于新文件）或文件的变化部分（对于原有文件） 01. 支持拷贝普通文件与特殊文件如链接文件，设备等。 02. 可以有排除指定文件或目录同步的功能，相当于打包命令tar的排除功能。 #tar zcvf backup_1.tar.gz /opt/data -exclude=clsn 说明：在打包/opt/data时就排除了clsn命名的目录和文件。 03. 可以做到保持原文件或目录的权限、时间、软硬链接、属主、组等所有属性均不改变-p。 04. 可实现增量同步，既只同步发生变化的数据，因此数据传输效率很高（tar -N）。 # 将备份/home 目录自 2008-01-29 以来修改过的文件 # tar -N 2008-01-29 -zcvf /backups/inc-backup_$(date +%F).tar.gz /home # 将备份 /home 目录昨天以来修改过的文件 # tar -N $(date -d yesterday \"+%F\") -zcvf /backups/inc-backup_$(date +%F).tar.gz /home # 添加文件到已经打包的文件 # tar -rf all.tar *.gif 说明：这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 05. 可以使用rcp,rsh,ssh等方式来配合进行隧道加密传输文件（rsync本身不对数据加密） 06. 可以通过socket(进程方式)传输文件和数据（服务端和客户端）*****。重点掌握 07. 支持匿名的或认证（无需系统用户）的进程模式传输，可实现方便安全的进行数据备份及镜像。 安装 网址：https://rsync.samba.org/ 安装依赖帮助：https://github.com/WayneD/rsync/blob/master/INSTALL.md sudo yum -y install epel-release sudo yum -y install gcc g++ gawk autoconf automake python3-pip sudo yum -y install acl libacl-devel sudo yum -y install attr libattr-devel sudo yum -y install xxhash-devel sudo yum -y install libzstd-devel sudo yum -y install lz4-devel sudo yum -y install openssl-devel pip3 install --user commonmark cd /usr/local/src wget https://rsync.samba.org/ftp/rsync/src/rsync-3.2.0.tar.gz tar zxf rsync-3.2.0.tar.gz && cd rsync-3.2.0 && ./configure --prefix=/usr/local/rsync 功能介绍 类似于 cp，本地备份传输数据 ➜ [/root] rsync /home/lxj/index.html /root 类似于scp，远程备份传输数据 ➜ [/root] rsync -rp /root/index.html 192.168.44.130:/root/test/ root@192.168.44.130's password: 类似于rm 实现无差异同步备份 将test2文件夹中所有内容备份到 test目录下 ➜ [/root] rsync -a --delete /root/test2 /root/test ➜ [/root] l test total 8.0K drwxr-xr-x. 3 root root 37 Jan 4 17:48 . dr-xr-x---. 10 root root 4.0K Jan 4 17:48 .. -rw-r--r--. 1 root root 25 Jan 4 17:42 index.html drwxr-xr-x. 2 root root 22 Jan 4 17:47 test2 类似于ls 本地文件查看 ➜ [/root] rsync index.html -rw-r--r-- 25 2021/01/04 16:56:43 index.html # 远程查看文件 ➜ [/root] rsync 192.168.44.130:/root/test/ root@192.168.44.130's password: -rw-r--r-- 25 2021/01/04 17:38:22 index.html Rsync的企业工作场景说明 两台服务器之间数据同步（定时任务cron+rsync） 同步网站内部人员数据信息（定时任务最小周期为1分钟） 两台服务器之间数据同步（实时任务inotify/sersync/lrsyncd+rsync） 同步网站用户人员数据信息 远程数据同步方式（类似SCP） push推到远程,将本地数据，推送到远程 rsync [option] src [user@]host:dest # 将本地/root/test目录及目录本身推送到远程 ➜ [/root] rsync -r /root/test lxj@192.168.44.130:/home/lxj /test --将test目录本身及目录下的内容进行传输 /test/ --只传输test目录下面的内容信息 将从远程拉取pull,将远程数据拉取到本地 rsync [option] [user@]host:src [dest] #将远端index.html文件拉取到本地目录 ➜ [/root] rsync lxj@192.168.44.130:/home/lxj/test/index.html /root 守护进程方式同步数据 服务器 创建rsync用户 useradd -s /sbin/nologin -M rsync 创建数据备份储存目录,目录修改属主 [root@backup ~]# mkdir /backup/ [root@backup ~]# chown -R rsync.rsync /backup/ 创建认证用户密码文件 echo \"rsync_backup:clsn123\" >>/etc/rsync.password chmod 600 /etc/rsync.password 启动rsync服 rsync --daemon 服务端配置完成 [root@backup ~]# ps -ef |grep rsync [root@backup ~]# netstat -lntup |grep rsync 客户端 创建认证文件 客户端的认证文件只需要有密码即可 echo \"clsn123\" >>/etc/rsync.password chmod 600 /etc/rsync.password 实现数据传输 交互式 [root@nfs01 ~]# rsync -avzP /etc/hosts rsync_backup@172.16.1.41::backup Password: sending incremental file list hosts 357 100% 0.00kB/s 0:00:00 (xfer#1, to-check=0/1) sent 63 bytes received 33 bytes 9.14 bytes/sec total size is 357 speedup is 3.72 免交互式 [root@nfs01 ~]# rsync -avzP /etc/hosts rsync_backup@172.16.1.41::backup --password-file=/etc/rsync.password sending incremental file list hosts 357 100% 0.00kB/s 0:00:00 (xfer#1, to-check=0/1) sent 199 bytes received 27 bytes 150.67 bytes/sec total size is 357 speedup is 1.58 配置文件 https://clsn.io/clsn/lx920.html#3_rsycn_rsyncdconf ➜ [/root] vim /etc/rsyncd.conf # 没有则手动创建 man rsyncd.conf rsync + inotify 实时同步 var className='atoc';"},"Python/Modules/Flask/flask博客.html":{"url":"Python/Modules/Flask/flask博客.html","title":"Flask博客","keywords":"","body":"http://www.bjhee.com/flask-ad1.html var className='atoc';"},"Python/Modules/SQLalchemy/sqlacodegen.html":{"url":"Python/Modules/SQLalchemy/sqlacodegen.html","title":"Sqlacodegen","keywords":"","body":"pip install sqlacodegen 导出整个数据库 sqlacodegen --outfile=models.py mysql://root:guess@192.168.1.250:3306/test # 账号：root # 密码：guess # 数据库服务器地址：192.168.1.250 # 数据库端口：3306 # 数据库名：test 导出某些表 sqlacodegen --outfile=models.py mysql://root:guess@192.168.1.250:3306/test --tables teacher,student 要导出的表：teacher、student var className='atoc';"},"Python/Modules/SQLalchemy/sqlalchemy博客.html":{"url":"Python/Modules/SQLalchemy/sqlalchemy博客.html","title":"Sqlalchemy博客","keywords":"","body":"https://www.keakon.net/2012/12/03/SQLAlchemy%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C python对Mysql操作和使用ORM框架（SQLAlchemy） - 君醉 - 博客园 https://www.cnblogs.com/pycode/p/mysql-orm.html var className='atoc';"},"Python/Modules/Untitled.html":{"url":"Python/Modules/Untitled.html","title":"Untitled","keywords":"","body":"var className='atoc';"},"Python/Modules/celery/任务回调.html":{"url":"Python/Modules/celery/任务回调.html","title":"任务回调","keywords":"","body":"2.3 任务状态回调 实际场景中得知任务状态是很常见的需求，对于 Celery 其内建任务状态有如下几种： 参数 说明 PENDING 任务等待中 STARTED 任务已开始 SUCCESS 任务执行成功 FAILURE 任务执行失败 RETRY 任务将被重试 REVOKED 任务取消 当我们有个耗时时间较长的任务进行时一般我们想得知它的实时进度，这里就需要我们自定义一个任务状态用来说明进度并手动更新状态，从而告诉回调当前任务的进度，具体实现： tasks.py from celery import Celery import time @app.task(bind=True) def test_mes(self): for i in xrange(1, 11): time.sleep(0.1) self.update_state(state=\"PROGRESS\", meta={'p': i*10}) return 'finish' 然后在 trigger.py 中增加： trigger.py from task import add,test_mes import sys def pm(body): res = body.get('result') if body.get('status') == 'PROGRESS': sys.stdout.write('\\r任务进度: {0}%'.format(res.get('p'))) sys.stdout.flush() else: print '\\r' print res r = test_mes.delay() print r.get(on_message=pm, propagate=False) 然后运行任务： 链式任务 def update_page_info(url): # fetch_page -> parse_page -> store_page chain = fetch_page.s(url) | parse_page.s() | store_page_info.s(url) chain() @app.task() def fetch_page(url): return myhttplib.get(url) @app.task() def parse_page(page): return myparser.parse_document(page) @app.task(ignore_result=True) def store_page_info(info, url): PageInfo.objects.create(url=url, info=info) 正确示范2 fetch_page.apply_async((url), link=[parse_page.s(), store_page_info.s(url)]) 链式任务中前一个任务的返回值默认是下一个任务的输入值之一 ( 不想让返回值做默认参数可以用 si() 或者 s(immutable=True) 的方式调用 )。 这里的 s() 是方法 celery.signature() 的快捷调用方式，signature 具体作用就是生成一个包含调用任务及其调用参数与其他信息的对象，个人感觉有点类似偏函数的概念：先不执行任务，而是把任务与任务参数存起来以供其他地方调用 2.7 关于 AsyncResult AsyncResult 主要用来储存任务执行信息与执行结果，有点类似 tornado 中的 Future 对象，都有储存异步结果与任务执行状态的功能，对于写 js 的朋友，它有点类似 Promise 对象，当然在 Celery 4.0 中已经支持了 promise 协议，只需要配合 gevent 一起使用就可以像写 js promise 一样写回调： import gevent.monkey monkey.patch_all() import time from celery import Celery app = Celery(broker='amqp://', backend='rpc') @app.task def add(x, y): return x + y def on_result_ready(result): print('Received result for id %r: %r' % (result.id, result.result,)) add.delay(2, 2).then(on_result_ready) 要注意的是这种 promise 写法现在只能用在 backend 是 RPC (amqp) 或 Redis 时。 并且独立使用时需要引入 gevent 的猴子补丁，可能会影响其他代码。 官方文档给的建议是这个特性结合异步框架使用更合适，例如 tornado、 twisted 等。 delay 与 apply_async 生成的都是 AsyncResult 对象，此外我们还可以根据 task id 直接获取相关 task 的 AsyncResult: AsyncResult(task_id=xxx) 关于 AsyncResult 更详细的内容，可以参考这里 利用 Celery 进行分布式队列管理、开发将会大幅提升开发效率， var className='atoc';"},"Python/Modules/longging 日志模块.html":{"url":"Python/Modules/longging 日志模块.html","title":"Longging 日志模块","keywords":"","body":" pingan 日志模块示例： python 官方文档 级别 何时使用 DEBUG 细节信息，仅当诊断问题时适用。 INFO 确认程序按预期运行 WARNING 表明有已经或即将发生的意外（例如：磁盘空间不足）。程序仍按预期进行 ERROR 由于严重的问题，程序的某些功能已经不能正常执行 CRITICAL 严重的错误，表明程序已不能继续执行 pingan 日志模块示例： from datetime import datetime import logging import os _DEBUG_LOGGER = logging.getLogger('debug') def cur_timestamp(): return datetime.datetime.now().strftime('%Y%m%d%H%M%S') def cur_date(): return datetime.datetime.now().starftime('%Y%m%d') def get_logger(): global LOGGER return LOGGER def get_filename(root, sub_log_folder, log_name='debug'): file_fields = [log_name] file_fields.append(cur_date) filename = '_'.join(file_fields) + '.log' log_dir_path = os.path.join(root, 'log', sub_log_folder) if not os.path.exists(log_dir_path): os.makedirs(log_dir_path, exist_ok=True) return os.path.join(root, log_dir_path, filename) def setup(root, sub_log_folder, log_name, level=logging.DEBUG, console=True): global _DEBUG_LOGGER filename = get_filename(root, sub_log_folder, log_name) file_handler = logging.FileHandler( filename, mode='a', encoding='utf-8', delay=False) console_handler = logging, StreamHandler() log_format = '%(levelname)s %(asctime)s %(module)s %(process)d %(message)s' debug_formatter = logging.Formatter(log_format) file_handler.setFormatter(debug_formatter) if not level: _DEBUG_LOGGER.setLevel(logging.DEBUG) else: _DEBUG_LOGGER.setLevel(level) _DEBUG_LOGGER.handler = [] _DEBUG_LOGGER.addHandler(file_handler) if console: _DEBUG_LOGGER.addHandler(console_handler) # ------- root = os.path.dirname(os.path.dirname( os.path.dirname(os.path.abspath(__file__)))) setup(root, 'task', 'log_name') logger = get_logger() var className='atoc';"},"Python/Modules/内置模块.html":{"url":"Python/Modules/内置模块.html","title":"内置模块","keywords":"","body":"内置模块 常用内置模块 builtins 内建函数默认加载 os 操作系统接口 sys python自身运行环境 functools 常用工具 json 编解码json对象 logging记录日志 time 时间 datetime 日期和时间 calendar 日历 multiprocessing 进程 threading 线程 copy 复制 hashilb 加密 from hashlib import * m = md5() pw = '111' # 使用MD5加密(不可逆) m.update(pw.encode()) # 打印加密后的结果 print(m.hexdigest()) re 正则 socket 标准BSD socket API 常用第三方模块 requests 网络请求，基于urllib3 urllib 基于http的高层库 scrapy 爬虫 beautifulsoup4 HTML/XML的解析器 celery 分布式任务调度模块 redis Pillow(PIL) 图像处理 elasticsearch 全文搜索引擎 pymysql 数据库连接 mongoengine/pymongo matplotlib 画图 numpy/scipy 科学计算 django/flask/tornado web框架 xmltodict xml转dict gevent 基于协程的python网络库 fabric 系统管理 pandas 数据处理库 scikit-learm 机器学习 python -m http.server 8888 python本地服务器开启 var className='atoc';"},"Python/Python Basics/python收集小知识.html":{"url":"Python/Python Basics/python收集小知识.html","title":"Python收集小知识","keywords":"","body":" 将python脚本当shell脚本一样运行 将python脚本当shell脚本一样运行 如果在脚本内容的开头已经给出了类似于如下的注释： #!/usr/bin/env python 那就可以直接在终端里运行：./*.py var className='atoc';"},"Python/Python Basics/python装饰器.html":{"url":"Python/Python Basics/python装饰器.html","title":"Python装饰器","keywords":"","body":" 装饰器Ddcorator 闭包 多重装饰器使用 类装饰器（一般不用） 几种装饰器示例： 装饰含有返回值的函数 装饰器实现登录验证简单原理 多个装饰器装饰一个函数 一 多个装饰器装饰一个函数 3层装饰器 参考：https://mp.weixin.qq.com/s/XTHZ-K1yDNPIoejNFvk6rw https://iswbm.com/47.html https://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&mid=2652569579&idx=1&sn=bc432ac7e7b0013b27cf4712080c328f&chksm=8464d7a1b3135eb7e89b83241cd844200e3ee724ed3e6e2e11472dabbd929ac24c4fe44a044b&mpshare=1&scene=1&srcid=#rd https://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&mid=2652569441&idx=1&sn=aaf6b48116aad898b07e8e8085b0d154&chksm=8464d72bb3135e3daa964ff1722b43c00fa624c3d7bd5561897ca477d908b8cf5f7c8997e67f&mpshare=1&scene=1&srcid=#rd Python自动化开发 - 装饰器 装饰器Ddcorator def func_out(func): def func_in(*args,**kwargs): # do something return func(*args,**kwargs) return func_in @funcOut # test = func_out(test) def test(*args): return *args 闭包 用途:可以在不修改源代码的前提下,添加新功能,如添加日志功能 可将单方法的类转换为函数 要有函数的嵌套 内部函数要使用外部函数作用域内的变量 外部函数必须有返回值,返回内部函数名 多重装饰器使用 挨着功能函数，从下至上依次装饰 并且执行依次先执行装饰器外层函数，后依次执行内层函数 类装饰器（一般不用） class TestDecorator(): def __init__(self,func): self.func = func print('class - test') self.func() # 调用 # 解决报错 TypeError: 'NoneType' object is not callable def __call__(self,*args,**kwargs): pass @TestDecorator def test(): print('test') 几种装饰器示例： 装饰含有返回值的函数 from functools import wraps def mywork(func): task_name = func.__name__ #此处为获得被装饰的函数名 a3 @warps(func) #防止被装饰的函数的函数名被改变 def inner(*args,**kwargs): print(\"添加1\") aa=func(*args,**kwargs) print(\"添加2\") return aa return inner @mywork def a3(arg1,arg2): print('i am zhangsan',arg1,arg2) li=[1,2,3,4,5,6] return li #返回一个列表 list=a3(\"参数1\",\"参数2\") #list等于inner的返回值 print(list) #li列表是a3的返回值，所以给在inner函数里执行的func()赋给aa，在通过inner的返回值就能拿到列表 #输出结果 添加1 i am zhangsan 参数1 参数2 添加2 [1, 2, 3, 4, 5, 6] 装饰器实现登录验证简单原理 def login(): name =input(\"输入用户名：\") if name == \"zhangsan\": return True else: return False def mywork(func): def inner(*args,**kwargs): lo_login = login() if not lo_login: #如果login()返回的是False return \"用户名错误!\" aa=func(*args,**kwargs) return aa return inner @mywork def a3(arg1,arg2): print('i am zhangsan',arg1,arg2) li=[1,2,3,4,5,6] return li list=a3(\"参数1\",\"参数2\") #list等于inner的返回值 print(list) #输出结果一 输入用户名：zs 用户名错误! #输出结果二： 输入用户名：zhangsan i am zhangsan 参数1 参数2 [1, 2, 3, 4, 5, 6] 多个装饰器装饰一个函数 一 def newwork1(func): def inner(): print(\"newwork1前\") func() print(\"newwork1后\") return inner def newwork2(func): def inner(): print(\"newwork2前\") func() print(\"newwork2后\") return inner @newwork2 @newwork1 def f1(): prin( 'i am zhangsan') f1() #输出结果： newwork2前 newwork1前 i am zhangsan newwork1后 newwork2后 多个装饰器装饰一个函数 def wrapper1(func): def inner1(): print('wrapper1 ,before func') ret = func() print('wrapper1 ,after func') return ret return inner1 def wrapper2(func): def inner2(): print('wrapper2 ,before func') ret = func() print('wrapper2 ,after func') return ret return inner2 def wrapper3(func): def inner3(): print('wrapper3 ,before func') ret = func() print('wrapper3 ,after func') return ret return inner3 @wrapper3 @wrapper2 @wrapper1 def f(): print('in f') return 'i am zhangsan' print(f()) #输出结果： wrapper3 ,before func wrapper2 ,before func wrapper1 ,before func in f wrapper1 ,after func wrapper2 ,after func wrapper3 ,after func i am zhangsan 3层装饰器 def Filter(a1,a2): def outer(func): def wrapper(request,kargs): print(a1) result=func(request,kargs) print(a2) return result return wrapper return outer aa=11 bb=22 @Filter(aa,bb) def Index(request,kargs): print(request,kargs) Index(\"zhangsan\",\"lisi\") #@Filter(aa,bb)会先执行Filter(aa,bb)函数，获取到返回值outer后拼接成@outer，之后就变成普通的装饰器了 #wrapper函数内可以使用a1,a2,request,kargs 4个参数 #输出结果 11 zhangsan lisi 22 var className='atoc';"},"Python/Python Basics/内存管理.html":{"url":"Python/Python Basics/内存管理.html","title":"内存管理","keywords":"","body":"python 中内部管理机制： gc机制 garbage collection （垃圾回收机制） 1. 引用计数机制 ``` python import gc sys.getrefcount() #获取引用计数 class Demo(object): def __init__(self): print(id(self)) def __new__(cls, *args, **kwargs): print('NEW') return super(Demo,cls).__new__(cls) def __del__(self): print('over') s = Demo() print('程序结束') ''' NEW 140636110471760 程序结束 over ''' s = Demo() del s print('程序结束') ''' NEW 140034811843152 over 程序结束 ''' #创建了对象s，初始计数为2，当代码运行结束后，会自动销毁对象s，释放内存 #当主动销毁对象释放内存的话，代码运行结束后不会最后再次销毁对象 ``` ​ 2. 隔代回收机制 gc.disable() # 关闭机制，手动查看 # （700，10，10） 隔代回收的默认阀值 属性拦截控制 getattribute var className='atoc';"},"Python/Python Basics/函数编程.html":{"url":"Python/Python Basics/函数编程.html","title":"函数编程","keywords":"","body":" 函数式编程的意义概念 高阶函数的使用 map() reduce() filter() sorted() lambda匿名函数 isinstance() 偏函数 给函数参数增加元信息 定义有默认参数的函数 减少可调用对象的参数个数 函数式编程的意义概念 高阶函数的使用 map() map(function，iterable...) # function---函数名 # iterable---一个或多个序列 reduce() from functools import reduce reduce(function, sequence[, initial]) -> value #function：有两个参数的额函数， 必需参数 #sequence: 元组、列表等可迭代对象， 必需参数 #inital： 初始值， 可选参数 在迭代sequence(tuple ，list ，dictionary， string等可迭代物)的过程中， 首先把 前两个元素传给 函数参数，函数加工后 然后把得到的结果和第三个元素作为两个参数传给函数参数， 函数加工后得到的结果又和第四个元素作为两个参数传给函数参数，依次类推 from functools import reduce def add(x,y): return x+y reduce(add,[1,2,3,4]) # 10 filter() filter(function，iterable) 过滤序列，保留True arr = [1,2,3,4,5,6] #只保留基数 odd_arr = list(filter(lambda x:x%2 !=0 ,arr)) print(odd_arr) # [1, 3, 5] sorted() sorted(List) 是重新生成一个排序后的对象 List.sort() 列表方法是更改原列表对象 sorted() #默认升序,从小到大 sorted(reverse=True) # 逆序 sorted(key=abs ) #按自定义key函数的规则排序(如abs绝对值) lambda匿名函数 isinstance() 偏函数 from functools import partial new_int = partial(int,base=2) new_int('1010') 给函数参数增加元信息 函数注解，运行跟不添加时一样，只是为了方便查看。 def demo(x: str, y: int) -> str: return x + str(y) # 查看函数注解 demo.__annotations__ 用mypy 进行静态类型检查mypy demo.py 定义有默认参数的函数 当定义默认参数时，注意定义的值None，如果比对的值是`0, False,None'或其他用来测试用户提供的值，有可能导致比对的结果有误（有可能用户传进来的就是这些合法的值） 此时可用创建_no_value 这种ogject()基类，只能测试同一性，并没其他作用 _no_value = object() def demo(a, b=_no_value): if b is _no_value: print('No b value supplied') return b def demo(a,b=None): if not b: pass 减少可调用对象的参数个数 partial() 函数允许给一个或多个参数设置固定的值，减少接下来被调用时的参 数个数 [ ] TODO 不太懂这里书中的用法及callback python cookbook 7.8 var className='atoc';"},"Python/Python Basics/并发编程.html":{"url":"Python/Python Basics/并发编程.html","title":"并发编程","keywords":"","body":" 创建子进程 使用继承的方式创建进程 进程池 队列使用 多线程 互斥锁 线程同步 生产者消费者模式 ThreadLocal 使用 创建子进程 import time from multiprocessing import Process def run_proc(name, age, **kwargs): for i in range(2): print('子进程运行中，参数name:{0},age:{1}'.format(name, age)) print('字典参数kwargs：', kwargs) time.sleep(0.5) if __name__ == \"__main__\": print('主进程开始运行') # 创建子进程 p = Process(target=run_proc, args=('test', 18), kwargs={'m': 23}) print('子进程将要执行') # 调用子进程 p.start() print(p.is_alive()) # 返回进程是否存活 p.join() # join方法，主进程等待调用join的子进程结束 join(3) 使用继承的方式创建进程 from multiprocessing import Process class ClockProc(Process): # 重新初始化 def __init__(self, interval): Process.__init__(self) self.interval = interval # 重新run def run(self): print('子进程开始') time.sleep(self.interval) print('子进程结束') if __name__ == \"__main__\": p = ClockProc(3) p.start() p.join(1) print('进程结束') 进程池 def funcpro(msg): print('start %s' % msg) time.sleep(3) print('end %s' % msg) if __name__ == \"__main__\": pool = multiprocessing.Pool(processes=3) for i in range(8): msg = 'HH %d' % i # 维持总进程数为process pool.apply_async(funcpro, (msg,)) pool.close() # 进程池关闭后不在接收新的请求 # 调用join之前先调用close，否则会出错 pool.join() print('结束') 队列使用 q = Queue(3) # 可以指定队列大小，默认为无限 # 插入数据 q.put('消息1') # q.put('消息',block=True,timeout=1) # 读取并删除元素 q.get() # 判断队列是否已满 q.full() # 队列是否已空 q.empty() # 查看队列大小 q.qsize() 多线程 from threading import Thread Thread(group=None, target=None, name=None, args=(), kwargs=()) # target:要执行的方法,name:线程名,args/kwargs 要传入方法的参数 run() start() # 启动进程 join([time]) # 等待至线程中止 isAlive() # 返回线程是否活动 getName() # 返回线程名 setName() # 设置线程名 # 通过继承threading.Thread 的方法来创建线程 # 这种方法需要重写run()方法, 然后调用start()创建线程 互斥锁 import threading class MyThread(threading.Thread): # func 线程函数,args传入线程的参数,name 线程名 def __init__(self, func, name, args): super().__init__(target=func, name=name, args=args) # 重写父类run方法 def run(self): self._target(*self._args) #lock = Lock() # 创建锁 #lock1 = Lock() #lock.acquire() # 上锁 #lock.release() # 释放锁 多个进程内全部变量是不共享的一个进程内,所有线程共享全局变量(不安全,需加互斥锁) from multiprocessing import Lock lock = Lock() num = 0 def theradtest1(): global num for i in range(200000): # threading.lock.acquire() lock.acquire() num += 1 lock.release() print('t1 %d' % num, end='\\n') def theradtest2(): global num for i in range(200000): lock.acquire() num += 1 lock.release() print('t2 %d' % num, end='\\n') if __name__ == \"__main__\": t1 = Thread(target=theradtest1) t2 = Thread(target=theradtest2) t1.start() t2.start() t1.join() t2.join() 线程同步 生产者消费者模式 ThreadLocal 使用 可以得出以下几点结论 单线程总是最慢的，多进程总是最快的。 多线程适合在IO密集场景下使用，譬如爬虫，网站开发等 多进程适合在对CPU计算运算要求较高的场景下使用，譬如大数据分析，机器学习等 多进程虽然总是最快的，但是不一定是最优的选择，因为它需要CPU资源支持下才能体现优势 var className='atoc';"},"Python/Python Basics/数据编码和处理.html":{"url":"Python/Python Basics/数据编码和处理.html","title":"数据编码和处理","keywords":"","body":" 参考书籍 python cookbook 读写CSV数据 读写JSON数据 解析转换XML数据 读写二进制数据等 struct模块 参考书籍 python cookbook 读写CSV数据 读写JSON数据 json.dumps() 对数据进行编码 python string--> json_obj json.loads() 对数据进行解码 json_string --> python_obj import json data = {'name':'LXJ','age':18,'sex':'man'} # json.dumps() 将python字典类型转换为JSON对象 json_str = json.dumps(data) print(json_str) #{\"name\": \"LXJ\", \"age\": 18, \"sex\": \"man\"} # 将JSON对象转换为python字典 data2 = json.loads(json_str) print(data2) print(type(data2)) print(data2['name'],data2.get('age')) {'name': 'LXJ', 'age': 18, 'sex': 'man'} LXJ 18 解析转换XML数据 读写二进制数据等 struct模块 var className='atoc';"},"Python/Python Basics/类与对象.html":{"url":"Python/Python Basics/类与对象.html","title":"类与对象","keywords":"","body":" 改变对象的字符串显示 with上下文管理器 私有方法(类中封装私有属性名) @property 创建可管理的属性 子类中扩展property @classmethod @staticmethod super()使用,调用父类的方法 简化数据结构的初始化 改变对象的字符串显示 with上下文管理器 编写上下文管理器的代码会放到with 语句中执行。 当出现with语句时，对象的__enter__()方法被触发，有值的时候赋给as变量，然后with语句执行，最后__exit__()方法被触发，执行清理工作，不论是否发生异常__exit__()都会执行，__exit__() 方法的第三个参数包含了异常类型、异常值和追溯信息 (如果有的话) from socket import socket, AF_INET, SOCK_STREAM class LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = family self.type = type self.connections = [] def __enter__(self): sock = socket(self.family, self.type) sock.connect(self.address) self.connections.append(sock) return sock def __exit__(self, exc_ty, exc_val, tb): self.connections.pop().close() 可以连续嵌套使用 from functools import partial conn = LazyConnection(('www.python.org', 80)) with conn as s1: pass with conn as s2: pass # s1 and s2 are independent sockets 如下例子，在flask中连接mysql数据库的使用 import MySQLdb class DataBase(object): def __init__(self, hostname, username, password, database, port, charset='utf-8'): self.conn = MySQLdb.Connect( host=hostname, user=username, passwd=password, db=database, port=port, charset=charset, autocommit=True ) self.cursor = self.conn.cursor() def __enter__(self): return self.cursor def __exit__(self, exc_type, exc_val, exc_tb): self.cursor.close() self.conn.close() def insert_val(self,val): pass #exc_type : Type 异常类型 #exc_val : Value 异常值 #exc_tb : TreacBack 异常回溯追踪 with Database() as db: db.insert_val(val) #db为enter方法返回的值 #exit 退出只能返回ture或者false,如果为false，with语句也会报错，exit语句需要接收参数 私有方法(类中封装私有属性名) 通常类中两个下划线开头的是私有的private，其他未公共的public 类内部可以访问私有属性(方法)，外部不可以访问 类外部通过_类名__私有属性(方法)名,_Person__name访问私有属性(方法) 单下划线_开头为保护类型的属性和方法，仅允许类内部和子类访问，类实例无法访问此属性和方法 单个下划线修饰的“_”的变量、函数、类在使用from xxx import *时都不会被导入 双下划线__开头为私有类型属性和方法，仅允许类内部访问，类实例和派生类均不能访问此属性和方法。 父类中属性名为__名字的，子类不继承，子类不能访问 方法本质上也是属性,只不过是可以通过()执行而已 @property 一个 property其实是 getter、setter 和 deleter 方法的集合，而不是单个方法 [ ] TODO 创建可管理的属性 class Person: def __init__(self, first_name): self.first_name = first_name # Getter function @property def first_name(self): return self._first_name # Setter function @first_name.setter def first_name(self, value): if not isinstance(value, str): raise TypeError('Expected a string') self._first_name = value # Deleter function (optional) @first_name.deleter def first_name(self): raise AttributeError(\"Can't delete attribute\") 子类中扩展property @classmethod @staticmethod super()使用,调用父类的方法 为了调用父类 (超类) 的一个方法，可以使用 super() 函数，比如： class A: def spam(self): print('A.spam') class B(A): def spam(self): print('B.spam') super().spam() # 调用父类中的spam() super() 函数的一个常见用法是在__ini__() 方法中确保父类被正确的初始化了： class A: def __init__(self): self.x = 0 class B(A): def __init__(self): super().__init__() self.y = 1 简化数据结构的初始化 [ ] todo python cook book 8.11 var className='atoc';"},"Python/Python Basics/网络编程.html":{"url":"Python/Python Basics/网络编程.html","title":"网络编程","keywords":"","body":" ip地址和端口 网络通信协议 套接字Socket编程 ip地址和端口 网络通信协议 tcp/ip 协议族 应用层（应用层，表示层，会话层） 传输层（TCP/UDP） 网络层（IP） 物理+数据链路层 TCP 是面向连接的，传输数据安全，稳定，效率相对较低 UDP是面向无连接的，传输数据不安全，效率高 套接字Socket编程 UDP 发送并接收数据 from socket import * # 创建套接字 udp_socket = socket(AF_INET,SOCK_DGRAM) # 绑定一个本机一个固定端口 udp_socket.bind(('',8989)) send_addr = ('192.168.10.1',8080) data = input('输入需要发送的信息') #发送数据 udp_socket.sendto(data.encode('gb2312'),send_addr) # 接收数据，本次接收最大字节数1024 recv_data = udp_socket.recvfrom(1024) print(recv_data[0].decode('gb2312')) #关闭套接字 udp_socket.close() UDP使用多线程实现聊天 from socket import * from threadiing import Thread udp_socket = socket(AF_INET,SOCK_DGRAM) udp_socket.bind(('',8989)) #接收 def reve_fun() while True: recv_data = udp_socket.recvfrom(1024) print('>>%:%s'%(srecv_data[1],recv_data[0].decode('gb2312')) #发送 def send_fun(): while True: addr = ('192.168.10.1',8080) data = input(' bilibili网络编程第7/8 节课 import struct tcp 编程 TCP SERVER端聊天实现 from socket import * server_socket = socket(AF_INET,SOCK_STREAM) # 绑定端口 server_socket.bind(('',10034)) #监听端口 server_socket.listen() #等待客户端的连接 client_socket,client_info = server_socket.accept() while True: #接收客户端发送的消息 recv_data = client_socket.recv(1024) print('客户端说：',recv_data('utf-8')) # 如果接收到bye就结束对话 if recv_data('utf-8') == 'bye' bread msg = input('>>') client_socket.send(msg,encode('utf-8')) client_socket.close() server_socket.close() TCP CLIENT端聊天实现 from socket import * client_socket = socket(AF_INET,SOCK_STREAM) #与服务器建立连接 client_socket.connect(('192.168.163.220',10034)) while True: #客户端发送消息 msg = input('>') client_socket.send(msg.encode('utf-8')) if msg == 'bye': break #客户端接收消息 recv_data = client_socket.recv(1024) print('服务器端说：',recv_data.decode('utf-8')) var className='atoc';"},"Python/Python Wheel/Django发送Email.html":{"url":"Python/Python Wheel/Django发送Email.html","title":"Django发送Email","keywords":"","body":"# Email django HTML页面邮件发送 import datetime import os, django from django.comf import settings from django.core.mail import EmailMultiAlternatives from django.template import loader os.environ.setdefault('DJANGO_SETTINGS_MODULEL', 'pa_sds.setting') djngo.setup() def send_mial(id_job): html_date = dict() title = '' #主题 reciptent_list = ['7634..'] #收件人 email_template_name = 'email.html' info = loader.get_template(email_template_name) html_content = info.render(html_date) msg = EmailMultiAlternatives( title, html_content, settings.Email_FROM, reciptent_list, ) mag.attach_alternative(html_content, 'text/html') mag.send() #时间时差： (create_date+datetime.timedelta(hours=8)).strftime(\"%Y-%m-%d %H:%M:%S\") var className='atoc';"},"Python/Python Wheel/python等环境安装.html":{"url":"Python/Python Wheel/python等环境安装.html","title":"Python等环境安装","keywords":"","body":"# -*- coding: utf-8 -*- # centos下用python2进行开发环境安装 import os class RunTool(object): '''安装工具/包/网址''' def __init__(self): pass def run_cmd(self, cmd): result = os.system(cmd) if not result == 0: return False # TODO 此处报错处理应用raise处理 return True def download_packets(self, url): # TODO 需判断URL为正确链接格式 # TODO 此处下载需要进行重试及下载完成验证 download_filename = url.split('/')[-1] if not self.check_exist_path(download_filename): download_cmd = 'wget %s' % (url) if self.run_cmd(download_cmd): if not self.check_exist_path(download_filename): return False return download_filename return download_filename def check_exist_path(self, path): return os.path.exists(path) def switch_path(self, path): '''切换工作路径''' return os.chdir(path) def yum_install(self, packet): return self.run_cmd('yum install -y %s' % (packet)) class LinuxInstall(RunTool): '''Linux环境及扩展安装''' def __init__(self): pass def check_install(self, base_packets): '''检查linux包是否安装''' has_been_install = [] for packet in base_packets: rpm_cmd = \"rpm -qa | egrep -i '%s'\" % (packet) rpm_results = os.popen(rpm_cmd).readlines() # 得到的结果列表 if rpm_results: for result in rpm_results: if packet in result: has_been_install.append(packet) has_install = list(set(has_been_install)) print('Have been install %s' % (has_install)) for install_packets in has_install: base_packets.remove(install_packets) return base_packets def replace_yum(self, yum_path, yum_url, old_yum): '''替换yum源''' # help doc: http://mirrors.163.com/.help/centos.html self.switch_path(yum_path) install_wget_name = self.check_install(['wget']) if len(install_wget_name) == 1: install_name = install_wget_name.pop() if self.yum_install(install_name): back_cmd = 'mv %s %s.back' % (old_yum, old_yum) if self.run_cmd(back_cmd): yum_file_name = self.download_packets(yum_url) if self.check_exist_path(yum_file_name): self.run_cmd('yum clean all') self.run_cmd('yum makecache') def install_linux_packets(self, base_packets): '''安装linux包''' install_packets = self.check_install(base_packets) if not install_packets: packets_str = ','.join(install_packets) print('%s packets has been install' % (packets_str)) return True for packet in install_packets: if self.run_cmd('yum install -y %s' % (packet)): if self.check_install([packet]): print('install %s packets failed' % (packet)) return False print('install %s packets success' % (packet)) return True class PythonInstall(RunTool): '''python3环境及虚拟环境安装''' def __init__(self, python_path): self.python_path = python_path self.virtualenv_install_path = self.python_path + '/bin/virtualenv' def install_python3(self, python3_down_url): # #TODO 除了下载链接，可以提供下载路径 if not self.check_exist_path(self.python_path): self.run_cmd('mkdir -p %s' % (self.python_path)) self.switch_path(self.python_path) down_filename = self.download_packets(python3_down_url) # 解压到指定路径 tar_python_cmd = 'tar -xzvf %s -C /%s' % ( down_filename, self.python_path) self.run_cmd(tar_python_cmd) tar_path = '.'.join(down_filename.split('.')[:-1]) self.switch_path('%s/%s' % (self.python_path, tar_path)) # 指定安装的python路径 install_python3_cmd = './configure --prefix=%s' % (self.python_path) self.run_cmd(install_python3_cmd) self.run_cmd('make && make install') # TODO判断软连接文件有问题 if self.check_exist_path('/usr/bin/python3'): self.run_cmd('rm -rf /usr/bin/python3') # 创建软链接 self.run_cmd('ln -s %s/bin/python3 /usr/bin/python3' % (self.python_path)) # 测试安装是否成功 if not self.run_cmd('python3 -V'): print('install python3 failed') return False print('install python3 success') return True def install_virtualenv(self, env_name, user): if self.run_cmd('%s/bin/pip3 install -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com virtualenv' % (self.python_path)): self.run_cmd('rm -rf /usr/bin/virtualenv') virtualenv_ln_cmd = 'ln -s %s /usr/bin/virtualenv' % ( self.virtualenv_install_path) if not self.run_cmd(virtualenv_ln_cmd): return 'install virtualenv failed' virtualenv_path = '/home/%s' % (user) if not self.check_exist_path(virtualenv_path): self.run_cmd('mkdir -p %s' % (virtualenv_path)) self.switch_path(virtualenv_path) chown_cmd = 'chown -R %s:%s %s' % (user, user, self.python_path) self.run_cmd(chown_cmd) virtualenv_cmd = 'virtualenv -p %s/bin/python3 %s' % ( self.python_path, env_name) if self.run_cmd(virtualenv_cmd): env_path = '%s/%s' % (virtualenv_path, env_name) chown_env_cmd = 'chown -R %s:%s %s' % (user, user, env_path) self.run_cmd(chown_env_cmd) # 激活虚拟环境 virtualenv_test_cmd = 'source %s/%s/bin/activate' % ( virtualenv_path, env_name) if self.run_cmd(virtualenv_test_cmd): print('install virtualenv success') return 'install virtualenv success' class ConfigArgs(object): BASE_PACKETS = ['gcc', 'wget', 'gdb', 'vim','net-tools'] PYTHON_RELY = ['zlib-devel', 'bzip2-devel', 'openssl-devel', 'ncurses-devel', 'sqlite-devel', 'readline-devel', 'tk-devel', 'gdbm-devel', 'db4-devel', 'libpcap-devel', 'xz-devel', 'libffi-devel'] YUM_PATH = '/etc/yum.repos.d' YUM_URL = 'http://mirrors.163.com/.help/CentOS7-Base-163.repo' OLD_YUM = 'CentOS-Base.repo' PYTHON_URL = 'https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz' PIP_URL = 'https://files.pythonhosted.org/packages/8e/76/66066b7bc71817238924c7e4b448abdb17eb0c92d645769c223f9ace478f/pip-20.0.2.tar.gz' PYTHON_PATH = '/tmp/python3' ENV_NAME = 'env' NORMAL_USER = 'cen' def main(): python_install = PythonInstall(ConfigArgs.PYTHON_PATH) linux_install = LinuxInstall() linux_install.replace_yum( ConfigArgs.YUM_PATH, ConfigArgs.YUM_URL, ConfigArgs.OLD_YUM) linux_base = linux_install.install_linux_packets( ConfigArgs.BASE_PACKETS+ConfigArgs.PYTHON_RELY) if linux_base: # # import pdb # # pdb.set_trace() result = python_install.install_python3(ConfigArgs.PYTHON_URL) if result: python_install.install_virtualenv( ConfigArgs.ENV_NAME, ConfigArgs.NORMAL_USER) result = python_install.install_python3(ConfigArgs.PYTHON_URL) if result: python_install.install_virtualenv( ConfigArgs.ENV_NAME, ConfigArgs.NORMAL_USER) if __name__ == \"__main__\": main() var className='atoc';"}}